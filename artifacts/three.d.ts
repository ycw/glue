// Generated by dts-bundle v0.7.3

declare module 'three' {
    
    export * from 'three/src/Three';
    
    export as namespace THREE;
}

declare module 'three/src/Three' {
    /**
        * SRC
        */
    export * from 'three/src/constants';
    export * from 'three/src/Three.Legacy';
    export * from 'three/src/utils';
    /**
        * Animation
        */
    export * from 'three/src/animation/tracks/VectorKeyframeTrack';
    export * from 'three/src/animation/tracks/StringKeyframeTrack';
    export * from 'three/src/animation/tracks/QuaternionKeyframeTrack';
    export * from 'three/src/animation/tracks/NumberKeyframeTrack';
    export * from 'three/src/animation/tracks/ColorKeyframeTrack';
    export * from 'three/src/animation/tracks/BooleanKeyframeTrack';
    export * from 'three/src/animation/PropertyMixer';
    export * from 'three/src/animation/PropertyBinding';
    export * from 'three/src/animation/KeyframeTrack';
    export * from 'three/src/animation/AnimationUtils';
    export * from 'three/src/animation/AnimationObjectGroup';
    export * from 'three/src/animation/AnimationMixer';
    export * from 'three/src/animation/AnimationClip';
    export * from 'three/src/animation/AnimationAction';
    /**
        * Audio
        */
    export * from 'three/src/audio/AudioListener';
    export * from 'three/src/audio/PositionalAudio';
    export * from 'three/src/audio/AudioContext';
    export * from 'three/src/audio/AudioAnalyser';
    export * from 'three/src/audio/Audio';
    /**
        * Cameras
        */
    export * from 'three/src/cameras/StereoCamera';
    export * from 'three/src/cameras/PerspectiveCamera';
    export * from 'three/src/cameras/OrthographicCamera';
    export * from 'three/src/cameras/CubeCamera';
    export * from 'three/src/cameras/ArrayCamera';
    export * from 'three/src/cameras/Camera';
    /**
        * Core
        */
    export * from 'three/src/core/Uniform';
    export * from 'three/src/core/InstancedBufferGeometry';
    export * from 'three/src/core/BufferGeometry';
    export * from 'three/src/core/InterleavedBufferAttribute';
    export * from 'three/src/core/InstancedInterleavedBuffer';
    export * from 'three/src/core/InterleavedBuffer';
    export * from 'three/src/core/InstancedBufferAttribute';
    export * from 'three/src/core/GLBufferAttribute';
    export * from 'three/src/core/BufferAttribute';
    export * from 'three/src/core/Object3D';
    export * from 'three/src/core/Raycaster';
    export * from 'three/src/core/Layers';
    export * from 'three/src/core/EventDispatcher';
    export * from 'three/src/core/Clock';
    /**
        * Extras
        */
    export * from 'three/src/extras/curves/Curves';
    export * from 'three/src/extras/core/Shape';
    export * from 'three/src/extras/core/Path';
    export * from 'three/src/extras/core/ShapePath';
    export * from 'three/src/extras/core/CurvePath';
    export * from 'three/src/extras/core/Curve';
    export * from 'three/src/extras/DataUtils';
    export * from 'three/src/extras/ImageUtils';
    export * from 'three/src/extras/ShapeUtils';
    export * from 'three/src/extras/PMREMGenerator';
    /**
        * Geometries
        */
    export * from 'three/src/geometries/Geometries';
    /**
        * Helpers
        */
    export * from 'three/src/helpers/SpotLightHelper';
    export * from 'three/src/helpers/SkeletonHelper';
    export * from 'three/src/helpers/PointLightHelper';
    export * from 'three/src/helpers/HemisphereLightHelper';
    export * from 'three/src/helpers/GridHelper';
    export * from 'three/src/helpers/PolarGridHelper';
    export * from 'three/src/helpers/DirectionalLightHelper';
    export * from 'three/src/helpers/CameraHelper';
    export * from 'three/src/helpers/BoxHelper';
    export * from 'three/src/helpers/Box3Helper';
    export * from 'three/src/helpers/PlaneHelper';
    export * from 'three/src/helpers/ArrowHelper';
    export * from 'three/src/helpers/AxesHelper';
    /**
        * Lights
        */
    export * from 'three/src/lights/SpotLightShadow';
    export * from 'three/src/lights/SpotLight';
    export * from 'three/src/lights/PointLight';
    export * from 'three/src/lights/PointLightShadow';
    export * from 'three/src/lights/RectAreaLight';
    export * from 'three/src/lights/HemisphereLight';
    export * from 'three/src/lights/DirectionalLightShadow';
    export * from 'three/src/lights/DirectionalLight';
    export * from 'three/src/lights/AmbientLight';
    export * from 'three/src/lights/LightShadow';
    export * from 'three/src/lights/Light';
    export * from 'three/src/lights/AmbientLightProbe';
    export * from 'three/src/lights/HemisphereLightProbe';
    export * from 'three/src/lights/LightProbe';
    /**
        * Loaders
        */
    export * from 'three/src/loaders/AnimationLoader';
    export * from 'three/src/loaders/CompressedTextureLoader';
    export * from 'three/src/loaders/DataTextureLoader';
    export * from 'three/src/loaders/CubeTextureLoader';
    export * from 'three/src/loaders/TextureLoader';
    export * from 'three/src/loaders/ObjectLoader';
    export * from 'three/src/loaders/MaterialLoader';
    export * from 'three/src/loaders/BufferGeometryLoader';
    export * from 'three/src/loaders/LoadingManager';
    export * from 'three/src/loaders/ImageLoader';
    export * from 'three/src/loaders/ImageBitmapLoader';
    export * from 'three/src/loaders/FileLoader';
    export * from 'three/src/loaders/Loader';
    export * from 'three/src/loaders/LoaderUtils';
    export * from 'three/src/loaders/Cache';
    export * from 'three/src/loaders/AudioLoader';
    /**
        * Materials
        */
    export * from 'three/src/materials/Materials';
    /**
        * Math
        */
    export * from 'three/src/math/interpolants/QuaternionLinearInterpolant';
    export * from 'three/src/math/interpolants/LinearInterpolant';
    export * from 'three/src/math/interpolants/DiscreteInterpolant';
    export * from 'three/src/math/interpolants/CubicInterpolant';
    export * from 'three/src/math/Interpolant';
    export * from 'three/src/math/Triangle';
    export * from 'three/src/math/Spherical';
    export * from 'three/src/math/Cylindrical';
    export * from 'three/src/math/Plane';
    export * from 'three/src/math/Frustum';
    export * from 'three/src/math/Sphere';
    export * from 'three/src/math/Ray';
    export * from 'three/src/math/Matrix4';
    export * from 'three/src/math/Matrix3';
    export * from 'three/src/math/Box3';
    export * from 'three/src/math/Box2';
    export * from 'three/src/math/Line3';
    export * from 'three/src/math/Euler';
    export * from 'three/src/math/Vector4';
    export * from 'three/src/math/Vector3';
    export * from 'three/src/math/Vector2';
    export * from 'three/src/math/Quaternion';
    export * from 'three/src/math/Color';
    export * from 'three/src/math/SphericalHarmonics3';
    import * as MathUtils from 'three/src/math/MathUtils';
    export { MathUtils };
    /**
        * Objects
        */
    export * from 'three/src/objects/Sprite';
    export * from 'three/src/objects/LOD';
    export * from 'three/src/objects/InstancedMesh';
    export * from 'three/src/objects/SkinnedMesh';
    export * from 'three/src/objects/Skeleton';
    export * from 'three/src/objects/Bone';
    export * from 'three/src/objects/Mesh';
    export * from 'three/src/objects/LineSegments';
    export * from 'three/src/objects/LineLoop';
    export * from 'three/src/objects/Line';
    export * from 'three/src/objects/Points';
    export * from 'three/src/objects/Group';
    /**
        * Renderers
        */
    export * from 'three/src/renderers/WebGLMultisampleRenderTarget';
    export * from 'three/src/renderers/WebGLCubeRenderTarget';
    export * from 'three/src/renderers/WebGLMultipleRenderTargets';
    export * from 'three/src/renderers/WebGLRenderTarget';
    export * from 'three/src/renderers/WebGLRenderer';
    export * from 'three/src/renderers/WebGL1Renderer';
    export * from 'three/src/renderers/WebGL3DRenderTarget';
    export * from 'three/src/renderers/WebGLArrayRenderTarget';
    export * from 'three/src/renderers/shaders/ShaderLib';
    export * from 'three/src/renderers/shaders/UniformsLib';
    export * from 'three/src/renderers/shaders/UniformsUtils';
    export * from 'three/src/renderers/shaders/ShaderChunk';
    export * from 'three/src/renderers/webgl/WebGLBufferRenderer';
    export * from 'three/src/renderers/webgl/WebGLCapabilities';
    export * from 'three/src/renderers/webgl/WebGLClipping';
    export * from 'three/src/renderers/webgl/WebGLCubeUVMaps';
    export * from 'three/src/renderers/webgl/WebGLExtensions';
    export * from 'three/src/renderers/webgl/WebGLGeometries';
    export * from 'three/src/renderers/webgl/WebGLIndexedBufferRenderer';
    export * from 'three/src/renderers/webgl/WebGLInfo';
    export * from 'three/src/renderers/webgl/WebGLLights';
    export * from 'three/src/renderers/webgl/WebGLObjects';
    export * from 'three/src/renderers/webgl/WebGLProgram';
    export * from 'three/src/renderers/webgl/WebGLPrograms';
    export * from 'three/src/renderers/webgl/WebGLProperties';
    export * from 'three/src/renderers/webgl/WebGLRenderLists';
    export * from 'three/src/renderers/webgl/WebGLShader';
    export * from 'three/src/renderers/webgl/WebGLShadowMap';
    export * from 'three/src/renderers/webgl/WebGLState';
    export * from 'three/src/renderers/webgl/WebGLTextures';
    export * from 'three/src/renderers/webgl/WebGLUniforms';
    export * from 'three/src/renderers/webxr/WebXR';
    export * from 'three/src/renderers/webxr/WebXRController';
    export * from 'three/src/renderers/webxr/WebXRManager';
    /**
        * Scenes
        */
    export * from 'three/src/scenes/FogExp2';
    export * from 'three/src/scenes/Fog';
    export * from 'three/src/scenes/Scene';
    /**
        * Textures
        */
    export * from 'three/src/textures/VideoTexture';
    export * from 'three/src/textures/DataTexture';
    export * from 'three/src/textures/DataTexture2DArray';
    export * from 'three/src/textures/DataTexture3D';
    export * from 'three/src/textures/CompressedTexture';
    export * from 'three/src/textures/CubeTexture';
    export * from 'three/src/textures/Data3DTexture';
    export * from 'three/src/textures/DataArrayTexture';
    export * from 'three/src/textures/CanvasTexture';
    export * from 'three/src/textures/DepthTexture';
    export * from 'three/src/textures/FramebufferTexture';
    export * from 'three/src/textures/Source';
    export * from 'three/src/textures/Texture';
}

declare module 'three/src/constants' {
    export const REVISION: string;
    
    export enum MOUSE {
        LEFT = 0,
        MIDDLE = 1,
        RIGHT = 2,
        ROTATE = 0,
        DOLLY = 1,
        PAN = 2,
    }
    
    export enum TOUCH {
        ROTATE,
        PAN,
        DOLLY_PAN,
        DOLLY_ROTATE,
    }
    
    export enum CullFace {}
    export const CullFaceNone: CullFace;
    export const CullFaceBack: CullFace;
    export const CullFaceFront: CullFace;
    export const CullFaceFrontBack: CullFace;
    
    export enum ShadowMapType {}
    export const BasicShadowMap: ShadowMapType;
    export const PCFShadowMap: ShadowMapType;
    export const PCFSoftShadowMap: ShadowMapType;
    export const VSMShadowMap: ShadowMapType;
    
    
    export enum Side {}
    export const FrontSide: Side;
    export const BackSide: Side;
    export const DoubleSide: Side;
    
    export enum Shading {}
    export const FlatShading: Shading;
    export const SmoothShading: Shading;
    
    export enum Blending {}
    export const NoBlending: Blending;
    export const NormalBlending: Blending;
    export const AdditiveBlending: Blending;
    export const SubtractiveBlending: Blending;
    export const MultiplyBlending: Blending;
    export const CustomBlending: Blending;
    
    export enum BlendingEquation {}
    export const AddEquation: BlendingEquation;
    export const SubtractEquation: BlendingEquation;
    export const ReverseSubtractEquation: BlendingEquation;
    export const MinEquation: BlendingEquation;
    export const MaxEquation: BlendingEquation;
    
    export enum BlendingDstFactor {}
    export const ZeroFactor: BlendingDstFactor;
    export const OneFactor: BlendingDstFactor;
    export const SrcColorFactor: BlendingDstFactor;
    export const OneMinusSrcColorFactor: BlendingDstFactor;
    export const SrcAlphaFactor: BlendingDstFactor;
    export const OneMinusSrcAlphaFactor: BlendingDstFactor;
    export const DstAlphaFactor: BlendingDstFactor;
    export const OneMinusDstAlphaFactor: BlendingDstFactor;
    export const DstColorFactor: BlendingDstFactor;
    export const OneMinusDstColorFactor: BlendingDstFactor;
    
    export enum BlendingSrcFactor {}
    export const SrcAlphaSaturateFactor: BlendingSrcFactor;
    
    export enum DepthModes {}
    export const NeverDepth: DepthModes;
    export const AlwaysDepth: DepthModes;
    export const LessDepth: DepthModes;
    export const LessEqualDepth: DepthModes;
    export const EqualDepth: DepthModes;
    export const GreaterEqualDepth: DepthModes;
    export const GreaterDepth: DepthModes;
    export const NotEqualDepth: DepthModes;
    
    export enum Combine {}
    export const MultiplyOperation: Combine;
    export const MixOperation: Combine;
    export const AddOperation: Combine;
    
    export enum ToneMapping {}
    export const NoToneMapping: ToneMapping;
    export const LinearToneMapping: ToneMapping;
    export const ReinhardToneMapping: ToneMapping;
    export const CineonToneMapping: ToneMapping;
    export const ACESFilmicToneMapping: ToneMapping;
    export const CustomToneMapping: ToneMapping;
    
    export enum Mapping {}
    export const UVMapping: Mapping;
    export const CubeReflectionMapping: Mapping;
    export const CubeRefractionMapping: Mapping;
    export const EquirectangularReflectionMapping: Mapping;
    export const EquirectangularRefractionMapping: Mapping;
    export const CubeUVReflectionMapping: Mapping;
    export const CubeUVRefractionMapping: Mapping;
    
    export enum Wrapping {}
    export const RepeatWrapping: Wrapping;
    export const ClampToEdgeWrapping: Wrapping;
    export const MirroredRepeatWrapping: Wrapping;
    
    export enum TextureFilter {}
    export const NearestFilter: TextureFilter;
    export const NearestMipmapNearestFilter: TextureFilter;
    export const NearestMipMapNearestFilter: TextureFilter;
    export const NearestMipmapLinearFilter: TextureFilter;
    export const NearestMipMapLinearFilter: TextureFilter;
    export const LinearFilter: TextureFilter;
    export const LinearMipmapNearestFilter: TextureFilter;
    export const LinearMipMapNearestFilter: TextureFilter;
    export const LinearMipmapLinearFilter: TextureFilter;
    export const LinearMipMapLinearFilter: TextureFilter;
    
    export enum TextureDataType {}
    export const UnsignedByteType: TextureDataType;
    export const ByteType: TextureDataType;
    export const ShortType: TextureDataType;
    export const UnsignedShortType: TextureDataType;
    export const IntType: TextureDataType;
    export const UnsignedIntType: TextureDataType;
    export const FloatType: TextureDataType;
    export const HalfFloatType: TextureDataType;
    export const UnsignedShort4444Type: TextureDataType;
    export const UnsignedShort5551Type: TextureDataType;
    export const UnsignedInt248Type: TextureDataType;
    
    export enum PixelFormat {}
    export const AlphaFormat: PixelFormat;
    export const RGBFormat: PixelFormat;
    export const RGBAFormat: PixelFormat;
    export const LuminanceFormat: PixelFormat;
    export const LuminanceAlphaFormat: PixelFormat;
    export const DepthFormat: PixelFormat;
    export const DepthStencilFormat: PixelFormat;
    export const RedFormat: PixelFormat;
    export const RedIntegerFormat: PixelFormat;
    export const RGFormat: PixelFormat;
    export const RGIntegerFormat: PixelFormat;
    export const RGBAIntegerFormat: PixelFormat;
    export const _SRGBFormat: PixelFormat; // fallback for WebGL 1
    export const _SRGBAFormat: PixelFormat; // fallback for WebGL 1
    
    export type PixelFormatGPU =
        | 'ALPHA'
        | 'RGB'
        | 'RGBA'
        | 'LUMINANCE'
        | 'LUMINANCE_ALPHA'
        | 'RED_INTEGER'
        | 'R8'
        | 'R8_SNORM'
        | 'R8I'
        | 'R8UI'
        | 'R16I'
        | 'R16UI'
        | 'R16F'
        | 'R32I'
        | 'R32UI'
        | 'R32F'
        | 'RG8'
        | 'RG8_SNORM'
        | 'RG8I'
        | 'RG8UI'
        | 'RG16I'
        | 'RG16UI'
        | 'RG16F'
        | 'RG32I'
        | 'RG32UI'
        | 'RG32F'
        | 'RGB565'
        | 'RGB8'
        | 'RGB8_SNORM'
        | 'RGB8I'
        | 'RGB8UI'
        | 'RGB16I'
        | 'RGB16UI'
        | 'RGB16F'
        | 'RGB32I'
        | 'RGB32UI'
        | 'RGB32F'
        | 'RGB9_E5'
        | 'SRGB8'
        | 'R11F_G11F_B10F'
        | 'RGBA4'
        | 'RGBA8'
        | 'RGBA8_SNORM'
        | 'RGBA8I'
        | 'RGBA8UI'
        | 'RGBA16I'
        | 'RGBA16UI'
        | 'RGBA16F'
        | 'RGBA32I'
        | 'RGBA32UI'
        | 'RGBA32F'
        | 'RGB5_A1'
        | 'RGB10_A2'
        | 'RGB10_A2UI'
        | 'SRGB8_ALPHA8'
        | 'SRGB8'
        | 'DEPTH_COMPONENT16'
        | 'DEPTH_COMPONENT24'
        | 'DEPTH_COMPONENT32F'
        | 'DEPTH24_STENCIL8'
        | 'DEPTH32F_STENCIL8';
    
    export enum CompressedPixelFormat {}
    export const RGB_S3TC_DXT1_Format: CompressedPixelFormat;
    export const RGBA_S3TC_DXT1_Format: CompressedPixelFormat;
    export const RGBA_S3TC_DXT3_Format: CompressedPixelFormat;
    export const RGBA_S3TC_DXT5_Format: CompressedPixelFormat;
    
    export const RGB_PVRTC_4BPPV1_Format: CompressedPixelFormat;
    export const RGB_PVRTC_2BPPV1_Format: CompressedPixelFormat;
    export const RGBA_PVRTC_4BPPV1_Format: CompressedPixelFormat;
    export const RGBA_PVRTC_2BPPV1_Format: CompressedPixelFormat;
    
    export const RGB_ETC1_Format: CompressedPixelFormat;
    export const RGB_ETC2_Format: CompressedPixelFormat;
    export const RGBA_ETC2_EAC_Format: CompressedPixelFormat;
    
    export const RGBA_ASTC_4x4_Format: CompressedPixelFormat;
    export const RGBA_ASTC_5x4_Format: CompressedPixelFormat;
    export const RGBA_ASTC_5x5_Format: CompressedPixelFormat;
    export const RGBA_ASTC_6x5_Format: CompressedPixelFormat;
    export const RGBA_ASTC_6x6_Format: CompressedPixelFormat;
    export const RGBA_ASTC_8x5_Format: CompressedPixelFormat;
    export const RGBA_ASTC_8x6_Format: CompressedPixelFormat;
    export const RGBA_ASTC_8x8_Format: CompressedPixelFormat;
    export const RGBA_ASTC_10x5_Format: CompressedPixelFormat;
    export const RGBA_ASTC_10x6_Format: CompressedPixelFormat;
    export const RGBA_ASTC_10x8_Format: CompressedPixelFormat;
    export const RGBA_ASTC_10x10_Format: CompressedPixelFormat;
    export const RGBA_ASTC_12x10_Format: CompressedPixelFormat;
    export const RGBA_ASTC_12x12_Format: CompressedPixelFormat;
    
    export const RGBA_BPTC_Format: CompressedPixelFormat;
    
    export enum AnimationActionLoopStyles {}
    export const LoopOnce: AnimationActionLoopStyles;
    export const LoopRepeat: AnimationActionLoopStyles;
    export const LoopPingPong: AnimationActionLoopStyles;
    
    export enum InterpolationModes {}
    export const InterpolateDiscrete: InterpolationModes;
    export const InterpolateLinear: InterpolationModes;
    export const InterpolateSmooth: InterpolationModes;
    
    export enum InterpolationEndingModes {}
    export const ZeroCurvatureEnding: InterpolationEndingModes;
    export const ZeroSlopeEnding: InterpolationEndingModes;
    export const WrapAroundEnding: InterpolationEndingModes;
    
    export enum AnimationBlendMode {}
    export const NormalAnimationBlendMode: AnimationBlendMode;
    export const AdditiveAnimationBlendMode: AnimationBlendMode;
    
    export enum TrianglesDrawModes {}
    export const TrianglesDrawMode: TrianglesDrawModes;
    export const TriangleStripDrawMode: TrianglesDrawModes;
    export const TriangleFanDrawMode: TrianglesDrawModes;
    
    export enum TextureEncoding {}
    export const LinearEncoding: TextureEncoding;
    export const sRGBEncoding: TextureEncoding;
    export const LogLuvEncoding: TextureEncoding;
    
    export enum DepthPackingStrategies {}
    export const BasicDepthPacking: DepthPackingStrategies;
    export const RGBADepthPacking: DepthPackingStrategies;
    
    export enum NormalMapTypes {}
    export const TangentSpaceNormalMap: NormalMapTypes;
    export const ObjectSpaceNormalMap: NormalMapTypes;
    
    export enum StencilOp {}
    export const ZeroStencilOp: StencilOp;
    export const KeepStencilOp: StencilOp;
    export const ReplaceStencilOp: StencilOp;
    export const IncrementStencilOp: StencilOp;
    export const DecrementStencilOp: StencilOp;
    export const IncrementWrapStencilOp: StencilOp;
    export const DecrementWrapStencilOp: StencilOp;
    export const InvertStencilOp: StencilOp;
    
    export enum StencilFunc {}
    export const NeverStencilFunc: StencilFunc;
    export const LessStencilFunc: StencilFunc;
    export const EqualStencilFunc: StencilFunc;
    export const LessEqualStencilFunc: StencilFunc;
    export const GreaterStencilFunc: StencilFunc;
    export const NotEqualStencilFunc: StencilFunc;
    export const GreaterEqualStencilFunc: StencilFunc;
    export const AlwaysStencilFunc: StencilFunc;
    
    export enum Usage {}
    export const StaticDrawUsage: Usage;
    export const DynamicDrawUsage: Usage;
    export const StreamDrawUsage: Usage;
    export const StaticReadUsage: Usage;
    export const DynamicReadUsage: Usage;
    export const StreamReadUsage: Usage;
    export const StaticCopyUsage: Usage;
    export const DynamicCopyUsage: Usage;
    export const StreamCopyUsage: Usage;
    
    export enum GLSLVersion {}
    export const GLSL1: GLSLVersion;
    export const GLSL3: GLSLVersion;
    
    export type BuiltinShaderAttributeName =
        | 'position'
        | 'normal'
        | 'uv'
        | 'color'
        | 'skinIndex'
        | 'skinWeight'
        | 'instanceMatrix'
        | 'morphTarget0'
        | 'morphTarget1'
        | 'morphTarget2'
        | 'morphTarget3'
        | 'morphTarget4'
        | 'morphTarget5'
        | 'morphTarget6'
        | 'morphTarget7'
        | 'morphNormal0'
        | 'morphNormal1'
        | 'morphNormal2'
        | 'morphNormal3';
}

declare module 'three/src/Three.Legacy' {
    export {};
}

declare module 'three/src/utils' {
    import { Color } from 'three/src/math/Color';
    
    export type ColorRepresentation = Color | string | number;
}

declare module 'three/src/animation/tracks/VectorKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { InterpolationModes } from 'three/src/constants';
    export class VectorKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[], interpolation?: InterpolationModes);
        /**
          * @default 'vector'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/tracks/StringKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { InterpolationModes } from 'three/src/constants';
    export class StringKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[], interpolation?: InterpolationModes);
        /**
          * @default 'string'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/tracks/QuaternionKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { InterpolationModes } from 'three/src/constants';
    export class QuaternionKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[], interpolation?: InterpolationModes);
        /**
          * @default 'quaternion'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/tracks/NumberKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { InterpolationModes } from 'three/src/constants';
    export class NumberKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[], interpolation?: InterpolationModes);
        /**
          * @default 'number'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/tracks/ColorKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { InterpolationModes } from 'three/src/constants';
    export class ColorKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[], interpolation?: InterpolationModes);
        /**
          * @default 'color'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/tracks/BooleanKeyframeTrack' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    export class BooleanKeyframeTrack extends KeyframeTrack {
        constructor(name: string, times: any[], values: any[]);
        /**
          * @default 'bool'
          */
        ValueTypeName: string;
    }
}

declare module 'three/src/animation/PropertyMixer' {
    export class PropertyMixer {
        constructor(binding: any, typeName: string, valueSize: number);
        binding: any;
        valueSize: number;
        buffer: any;
        cumulativeWeight: number;
        cumulativeWeightAdditive: number;
        useCount: number;
        referenceCount: number;
        accumulate(accuIndex: number, weight: number): void;
        accumulateAdditive(weight: number): void;
        apply(accuIndex: number): void;
        saveOriginalState(): void;
        restoreOriginalState(): void;
    }
}

declare module 'three/src/animation/PropertyBinding' {
    export interface ParseTrackNameResults {
            nodeName: string;
            objectName: string;
            objectIndex: string;
            propertyName: string;
            propertyIndex: string;
    }
    export class PropertyBinding {
            constructor(rootNode: any, path: string, parsedPath?: any);
            path: string;
            parsedPath: any;
            node: any;
            rootNode: any;
            getValue(targetArray: any, offset: number): any;
            setValue(sourceArray: any, offset: number): void;
            bind(): void;
            unbind(): void;
            BindingType: {
                    [bindingType: string]: number;
            };
            Versioning: {
                    [versioning: string]: number;
            };
            GetterByBindingType: Array<() => void>;
            SetterByBindingTypeAndVersioning: Array<Array<() => void>>;
            static create(root: any, path: any, parsedPath?: any): PropertyBinding | PropertyBinding.Composite;
            /**
                * @internal
                */
            static sanitizeNodeName(name: string): string;
            static parseTrackName(trackName: string): ParseTrackNameResults;
            static findNode(root: any, nodeName: string): any;
    }
    export namespace PropertyBinding {
            class Composite {
                    constructor(targetGroup: any, path: any, parsedPath?: any);
                    /**
                        * @internal
                        */
                    getValue(array: any, offset: number): any;
                    /**
                        * @internal
                        */
                    setValue(array: any, offset: number): void;
                    /**
                        * @internal
                        */
                    bind(): void;
                    /**
                        * @internal
                        */
                    unbind(): void;
            }
    }
}

declare module 'three/src/animation/KeyframeTrack' {
    import { DiscreteInterpolant } from 'three/src/math/interpolants/DiscreteInterpolant';
    import { LinearInterpolant } from 'three/src/math/interpolants/LinearInterpolant';
    import { CubicInterpolant } from 'three/src/math/interpolants/CubicInterpolant';
    import { InterpolationModes } from 'three/src/constants';
    export class KeyframeTrack {
            constructor(name: string, times: ArrayLike<any>, values: ArrayLike<any>, interpolation?: InterpolationModes);
            name: string;
            times: Float32Array;
            values: Float32Array;
            /**
                * @internal
                */
            ValueTypeName: string;
            TimeBufferType: Float32Array;
            ValueBufferType: Float32Array;
            /**
                * @default THREE.InterpolateLinear
                */
            DefaultInterpolation: InterpolationModes;
            InterpolantFactoryMethodDiscrete(result: any): DiscreteInterpolant;
            InterpolantFactoryMethodLinear(result: any): LinearInterpolant;
            InterpolantFactoryMethodSmooth(result: any): CubicInterpolant;
            setInterpolation(interpolation: InterpolationModes): KeyframeTrack;
            getInterpolation(): InterpolationModes;
            getValueSize(): number;
            shift(timeOffset: number): KeyframeTrack;
            scale(timeScale: number): KeyframeTrack;
            trim(startTime: number, endTime: number): KeyframeTrack;
            validate(): boolean;
            optimize(): KeyframeTrack;
            clone(): this;
            static toJSON(track: KeyframeTrack): any;
    }
}

declare module 'three/src/animation/AnimationUtils' {
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    export namespace AnimationUtils {
        function arraySlice(array: any, from: number, to: number): any;
        function convertArray(array: any, type: any, forceClone: boolean): any;
        function isTypedArray(object: any): boolean;
        /**
          * @internal
          */
        function getKeyFrameOrder(times: number[]): number[];
        function sortedArray(values: any[], stride: number, order: number[]): any[];
        function flattenJSON(jsonKeys: string[], times: any[], values: any[], valuePropertyName: string): void;
        function subclip(sourceClip: AnimationClip, name: string, startFrame: number, endFrame: number, fps?: number): AnimationClip;
        function makeClipAdditive(targetClip: AnimationClip, referenceFrame?: number, referenceClip?: AnimationClip, fps?: number): AnimationClip;
    }
}

declare module 'three/src/animation/AnimationObjectGroup' {
    export class AnimationObjectGroup {
        constructor(...args: any[]);
        uuid: string;
        stats: {
            bindingsPerObject: number;
            objects: {
                total: number;
                inUse: number;
            };
        };
        readonly isAnimationObjectGroup: true;
        add(...args: any[]): void;
        remove(...args: any[]): void;
        uncache(...args: any[]): void;
    }
}

declare module 'three/src/animation/AnimationMixer' {
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    import { AnimationAction } from 'three/src/animation/AnimationAction';
    import { AnimationBlendMode } from 'three/src/constants';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { Object3D } from 'three/src/core/Object3D';
    import { AnimationObjectGroup } from 'three/src/animation/AnimationObjectGroup';
    export class AnimationMixer extends EventDispatcher {
            constructor(root: Object3D | AnimationObjectGroup);
            /**
                * @default 0
                */
            time: number;
            /**
                * @default 1.0
                */
            timeScale: number;
            clipAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup, blendMode?: AnimationBlendMode): AnimationAction;
            existingAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): AnimationAction | null;
            stopAllAction(): AnimationMixer;
            update(deltaTime: number): AnimationMixer;
            setTime(timeInSeconds: number): AnimationMixer;
            getRoot(): Object3D | AnimationObjectGroup;
            uncacheClip(clip: AnimationClip): void;
            uncacheRoot(root: Object3D | AnimationObjectGroup): void;
            uncacheAction(clip: AnimationClip, root?: Object3D | AnimationObjectGroup): void;
    }
}

declare module 'three/src/animation/AnimationClip' {
    import { KeyframeTrack } from 'three/src/animation/KeyframeTrack';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Bone } from 'three/src/objects/Bone';
    import { AnimationBlendMode } from 'three/src/constants';
    export interface MorphTarget {
            name: string;
            vertices: Vector3[];
    }
    export class AnimationClip {
            constructor(name?: string, duration?: number, tracks?: KeyframeTrack[], blendMode?: AnimationBlendMode);
            name: string;
            tracks: KeyframeTrack[];
            /**
                * @default THREE.NormalAnimationBlendMode
                * @internal
                */
            blendMode: AnimationBlendMode;
            /**
                * @default -1
                */
            duration: number;
            uuid: string;
            /**
                * @internal
                */
            results: any[];
            resetDuration(): AnimationClip;
            trim(): AnimationClip;
            validate(): boolean;
            optimize(): AnimationClip;
            clone(): this;
            toJSON(clip: AnimationClip): any;
            static CreateFromMorphTargetSequence(name: string, morphTargetSequence: MorphTarget[], fps: number, noLoop: boolean): AnimationClip;
            static findByName(clipArray: AnimationClip[], name: string): AnimationClip;
            static CreateClipsFromMorphTargetSequences(morphTargets: MorphTarget[], fps: number, noLoop: boolean): AnimationClip[];
            static parse(json: any): AnimationClip;
            static parseAnimation(animation: any, bones: Bone[]): AnimationClip;
            static toJSON(clip: AnimationClip): any;
    }
}

declare module 'three/src/animation/AnimationAction' {
    import { AnimationMixer } from 'three/src/animation/AnimationMixer';
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    import { AnimationActionLoopStyles, AnimationBlendMode } from 'three/src/constants';
    import { Object3D } from 'three/src/core/Object3D';
    export class AnimationAction {
            constructor(mixer: AnimationMixer, clip: AnimationClip, localRoot?: Object3D, blendMode?: AnimationBlendMode);
            /**
                * @internal
                */
            blendMode: AnimationBlendMode;
            /**
                * @default THREE.LoopRepeat
                */
            loop: AnimationActionLoopStyles;
            /**
                * @default 0
                */
            time: number;
            /**
                * @default 1
                */
            timeScale: number;
            /**
                * @default 1
                */
            weight: number;
            /**
                * @default Infinity
                */
            repetitions: number;
            /**
                * @default false
                */
            paused: boolean;
            /**
                * @default true
                */
            enabled: boolean;
            /**
                * @default false
                */
            clampWhenFinished: boolean;
            /**
                * @default true
                */
            zeroSlopeAtStart: boolean;
            /**
                * @default true
                */
            zeroSlopeAtEnd: boolean;
            play(): AnimationAction;
            stop(): AnimationAction;
            reset(): AnimationAction;
            isRunning(): boolean;
            isScheduled(): boolean;
            startAt(time: number): AnimationAction;
            setLoop(mode: AnimationActionLoopStyles, repetitions: number): AnimationAction;
            setEffectiveWeight(weight: number): AnimationAction;
            getEffectiveWeight(): number;
            fadeIn(duration: number): AnimationAction;
            fadeOut(duration: number): AnimationAction;
            crossFadeFrom(fadeOutAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
            crossFadeTo(fadeInAction: AnimationAction, duration: number, warp: boolean): AnimationAction;
            stopFading(): AnimationAction;
            setEffectiveTimeScale(timeScale: number): AnimationAction;
            getEffectiveTimeScale(): number;
            setDuration(duration: number): AnimationAction;
            syncWith(action: AnimationAction): AnimationAction;
            halt(duration: number): AnimationAction;
            warp(statTimeScale: number, endTimeScale: number, duration: number): AnimationAction;
            stopWarping(): AnimationAction;
            getMixer(): AnimationMixer;
            getClip(): AnimationClip;
            getRoot(): Object3D;
    }
}

declare module 'three/src/audio/AudioListener' {
    import { Object3D } from 'three/src/core/Object3D';
    import { AudioContext } from 'three/src/audio/AudioContext';
    export class AudioListener extends Object3D {
            constructor();
            /**
                * @internal
                */
            type: 'AudioListener';
            context: AudioContext;
            gain: GainNode;
            /**
                * @default null
                */
            filter: any;
            /**
                * @default 0
                */
            timeDelta: number;
            getInput(): GainNode;
            removeFilter(): this;
            setFilter(value: any): this;
            getFilter(): any;
            setMasterVolume(value: number): this;
            getMasterVolume(): number;
            /**
                * @internal
                */
            updateMatrixWorld(force?: boolean): void;
    }
}

declare module 'three/src/audio/PositionalAudio' {
    import { AudioListener } from 'three/src/audio/AudioListener';
    import { Audio } from 'three/src/audio/Audio';
    export class PositionalAudio extends Audio<PannerNode> {
        constructor(listener: AudioListener);
        panner: PannerNode;
        getOutput(): PannerNode;
        setRefDistance(value: number): this;
        getRefDistance(): number;
        setRolloffFactor(value: number): this;
        getRolloffFactor(): number;
        setDistanceModel(value: string): this;
        getDistanceModel(): string;
        setMaxDistance(value: number): this;
        getMaxDistance(): number;
        setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): this;
        /**
          * @internal
          */
        updateMatrixWorld(force?: boolean): void;
    }
}

declare module 'three/src/audio/AudioContext' {
    export namespace AudioContext {
        function getContext(): AudioContext;
        function setContext(): void;
    }
}

declare module 'three/src/audio/AudioAnalyser' {
    import { Audio } from 'three/src/audio/Audio';
    export class AudioAnalyser {
        constructor(audio: Audio<AudioNode>, fftSize?: number);
        analyser: AnalyserNode;
        data: Uint8Array;
        getFrequencyData(): Uint8Array;
        getAverageFrequency(): number;
        /**
          * @deprecated Use .getFrequencyData() instead.
          */
        getData(file: any): any;
    }
}

declare module 'three/src/audio/Audio' {
    import { Object3D } from 'three/src/core/Object3D';
    import { AudioListener } from 'three/src/audio/AudioListener';
    import { AudioContext } from 'three/src/audio/AudioContext';
    export class Audio<NodeType extends AudioNode = GainNode> extends Object3D {
            constructor(listener: AudioListener);
            type: 'Audio';
            listener: AudioListener;
            context: AudioContext;
            gain: GainNode;
            /**
                * @default false
                */
            autoplay: boolean;
            /**
                * @internal
                */
            buffer: null | AudioBuffer;
            /**
                * @default 0
                */
            detune: number;
            /**
                * @default false
                * @internal
                */
            loop: boolean;
            /**
                * @default 0
                * @internal
                */
            loopStart: number;
            /**
                * @default 0
                * @internal
                */
            loopEnd: number;
            /**
                * @default 0
                */
            offset: number;
            /**
                * @default undefined
                */
            duration: number | undefined;
            /**
                * @default 1
                */
            playbackRate: number;
            /**
                * @default false
                */
            isPlaying: boolean;
            /**
                * @default true
                */
            hasPlaybackControl: boolean;
            /**
                * @default 'empty'
                */
            sourceType: string;
            source: null | AudioBufferSourceNode;
            /**
                * @default []
                */
            filters: AudioNode[];
            getOutput(): NodeType;
            setNodeSource(audioNode: AudioBufferSourceNode): this;
            setMediaElementSource(mediaElement: HTMLMediaElement): this;
            setMediaStreamSource(mediaStream: MediaStream): this;
            setBuffer(audioBuffer: AudioBuffer): this;
            play(delay?: number): this;
            onEnded(): void;
            pause(): this;
            stop(): this;
            connect(): this;
            disconnect(): this;
            setDetune(value: number): this;
            getDetune(): number;
            getFilters(): AudioNode[];
            setFilters(value: AudioNode[]): this;
            getFilter(): AudioNode;
            setFilter(filter: AudioNode): this;
            setPlaybackRate(value: number): this;
            getPlaybackRate(): number;
            getLoop(): boolean;
            setLoop(value: boolean): this;
            setLoopStart(value: number): this;
            setLoopEnd(value: number): this;
            getVolume(): number;
            setVolume(value: number): this;
            /**
                * @deprecated Use AudioLoader instead.
                */
            load(file: string): Audio;
    }
}

declare module 'three/src/cameras/StereoCamera' {
    import { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera';
    import { Camera } from 'three/src/cameras/Camera';
    export class StereoCamera extends Camera {
            constructor();
            /**
                * @internal
                */
            type: 'StereoCamera';
            /**
                * @default 1
                */
            aspect: number;
            /**
                * @default 0.064
                */
            eyeSep: number;
            cameraL: PerspectiveCamera;
            cameraR: PerspectiveCamera;
            update(camera: PerspectiveCamera): void;
    }
}

declare module 'three/src/cameras/PerspectiveCamera' {
    import { Camera } from 'three/src/cameras/Camera';
    export class PerspectiveCamera extends Camera {
            constructor(fov?: number, aspect?: number, near?: number, far?: number);
            /**
                * @internal
                */
            type: 'PerspectiveCamera';
            readonly isPerspectiveCamera: true;
            /**
                * @default 1
                */
            zoom: number;
            /**
                * @default 50
                */
            fov: number;
            /**
                * @default 1
                */
            aspect: number;
            /**
                * @default 0.1
                */
            near: number;
            /**
                * @default 2000
                */
            far: number;
            /**
                * @default 10
                */
            focus: number;
            /**
                * @default null
                */
            view: null | {
                    enabled: boolean;
                    fullWidth: number;
                    fullHeight: number;
                    offsetX: number;
                    offsetY: number;
                    width: number;
                    height: number;
            };
            /**
                * @default 35
                */
            filmGauge: number;
            /**
                * @default 0
                */
            filmOffset: number;
            setFocalLength(focalLength: number): void;
            getFocalLength(): number;
            getEffectiveFOV(): number;
            getFilmWidth(): number;
            getFilmHeight(): number;
            setViewOffset(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number): void;
            clearViewOffset(): void;
            updateProjectionMatrix(): void;
            toJSON(meta?: any): any;
            /**
                * @deprecated Use .setFocalLength() and .filmGauge instead.
                */
            setLens(focalLength: number, frameHeight?: number): void;
    }
}

declare module 'three/src/cameras/OrthographicCamera' {
    import { Camera } from 'three/src/cameras/Camera';
    export class OrthographicCamera extends Camera {
            constructor(left?: number, right?: number, top?: number, bottom?: number, near?: number, far?: number);
            /**
                * @internal
                */
            type: 'OrthographicCamera';
            readonly isOrthographicCamera: true;
            /**
                * @default 1
                */
            zoom: number;
            /**
                * @default null
                */
            view: null | {
                    enabled: boolean;
                    fullWidth: number;
                    fullHeight: number;
                    offsetX: number;
                    offsetY: number;
                    width: number;
                    height: number;
            };
            /**
                * @default -1
                */
            left: number;
            /**
                * @default 1
                */
            right: number;
            /**
                * @default 1
                */
            top: number;
            /**
                * @default -1
                */
            bottom: number;
            /**
                * @default 0.1
                */
            near: number;
            /**
                * @default 2000
                */
            far: number;
            updateProjectionMatrix(): void;
            setViewOffset(fullWidth: number, fullHeight: number, offsetX: number, offsetY: number, width: number, height: number): void;
            clearViewOffset(): void;
            toJSON(meta?: any): any;
    }
}

declare module 'three/src/cameras/CubeCamera' {
    import { WebGLCubeRenderTarget } from 'three/src/renderers/WebGLCubeRenderTarget';
    import { Scene } from 'three/src/scenes/Scene';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { Object3D } from 'three/src/core/Object3D';
    export class CubeCamera extends Object3D {
        constructor(near: number, far: number, renderTarget: WebGLCubeRenderTarget);
        /**
          * @internal
          */
        type: 'CubeCamera';
        renderTarget: WebGLCubeRenderTarget;
        update(renderer: WebGLRenderer, scene: Scene): void;
    }
}

declare module 'three/src/cameras/ArrayCamera' {
    import { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera';
    export class ArrayCamera extends PerspectiveCamera {
        constructor(cameras?: PerspectiveCamera[]);
        /**
          * @default []
          */
        cameras: PerspectiveCamera[];
        readonly isArrayCamera: true;
    }
}

declare module 'three/src/cameras/Camera' {
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Object3D } from 'three/src/core/Object3D';
    export class Camera extends Object3D {
            constructor();
            /**
                * @default new THREE.Matrix4()
                */
            matrixWorldInverse: Matrix4;
            /**
                * @default new THREE.Matrix4()
                */
            projectionMatrix: Matrix4;
            /**
                * @default new THREE.Matrix4()
                */
            projectionMatrixInverse: Matrix4;
            readonly isCamera: true;
            getWorldDirection(target: Vector3): Vector3;
            /**
                * @internal
                */
            updateMatrixWorld(force?: boolean): void;
    }
}

declare module 'three/src/core/Uniform' {
    export class Uniform {
            constructor(value: any);
            constructor(type: string, value: any);
            /**
                * @deprecated
                */
            type: string;
            value: any;
            /**
                * @deprecated Use object.onBeforeRender() instead.
                */
            dynamic: boolean;
            /**
                * @internal
                */
            onUpdateCallback: () => void;
            /**
                * @deprecated Use object.onBeforeRender() instead.
                */
            onUpdate(callback: () => void): Uniform;
    }
}

declare module 'three/src/core/InstancedBufferGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class InstancedBufferGeometry extends BufferGeometry {
            constructor();
            /**
                * @default 'InstancedBufferGeometry
                * @internal
                */
            type: string;
            isInstancedBufferGeometry: boolean;
            /**
                * @internal
                */
            groups: Array<{
                    start: number;
                    count: number;
                    instances: number;
            }>;
            /**
                * @default Infinity
                */
            instanceCount: number;
            /**
                * @internal
                */
            addGroup(start: number, count: number, instances: number): void;
    }
}

declare module 'three/src/core/BufferGeometry' {
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { Box3 } from 'three/src/math/Box3';
    import { Sphere } from 'three/src/math/Sphere';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { Vector2 } from 'three/src/math/Vector2';
    import { Vector3 } from 'three/src/math/Vector3';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { InterleavedBufferAttribute } from 'three/src/core/InterleavedBufferAttribute';
    import { BuiltinShaderAttributeName } from 'three/src/constants';
    export class BufferGeometry extends EventDispatcher {
            constructor();
            /**
                * @internal
                */
            static MaxIndex: number;
            id: number;
            uuid: string;
            /**
                * @default ''
                */
            name: string;
            /**
                * @default 'BufferGeometry'
                * @internal
                */
            type: string;
            /**
                * @default null
                */
            index: BufferAttribute | null;
            /**
                * @default {}
                */
            attributes: {
                    [name: string]: BufferAttribute | InterleavedBufferAttribute;
            };
            /**
                * @default {}
                */
            morphAttributes: {
                    [name: string]: Array<BufferAttribute | InterleavedBufferAttribute>;
            };
            /**
                * @default false
                */
            morphTargetsRelative: boolean;
            /**
                * @default []
                */
            groups: Array<{
                    start: number;
                    count: number;
                    materialIndex?: number | undefined;
            }>;
            /**
                * @default null
                */
            boundingBox: Box3 | null;
            /**
                * @default null
                */
            boundingSphere: Sphere | null;
            /**
                * @default { start: 0, count: Infinity }
                */
            drawRange: {
                    start: number;
                    count: number;
            };
            /**
                * @default {}
                */
            userData: {
                    [key: string]: any;
            };
            readonly isBufferGeometry: true;
            getIndex(): BufferAttribute | null;
            setIndex(index: BufferAttribute | number[] | null): BufferGeometry;
            setAttribute(name: BuiltinShaderAttributeName | (string & {}), attribute: BufferAttribute | InterleavedBufferAttribute): BufferGeometry;
            getAttribute(name: BuiltinShaderAttributeName | (string & {})): BufferAttribute | InterleavedBufferAttribute;
            deleteAttribute(name: BuiltinShaderAttributeName | (string & {})): BufferGeometry;
            hasAttribute(name: BuiltinShaderAttributeName | (string & {})): boolean;
            addGroup(start: number, count: number, materialIndex?: number): void;
            clearGroups(): void;
            setDrawRange(start: number, count: number): void;
            applyMatrix4(matrix: Matrix4): BufferGeometry;
            applyQuaternion(q: Quaternion): BufferGeometry;
            rotateX(angle: number): BufferGeometry;
            rotateY(angle: number): BufferGeometry;
            rotateZ(angle: number): BufferGeometry;
            translate(x: number, y: number, z: number): BufferGeometry;
            scale(x: number, y: number, z: number): BufferGeometry;
            lookAt(v: Vector3): void;
            center(): BufferGeometry;
            setFromPoints(points: Vector3[] | Vector2[]): BufferGeometry;
            computeBoundingBox(): void;
            computeBoundingSphere(): void;
            computeTangents(): void;
            computeVertexNormals(): void;
            merge(geometry: BufferGeometry, offset?: number): BufferGeometry;
            normalizeNormals(): void;
            toNonIndexed(): BufferGeometry;
            toJSON(): any;
            clone(): BufferGeometry;
            copy(source: BufferGeometry): this;
            dispose(): void;
            /**
                * @deprecated Use .groups instead.
                */
            drawcalls: any;
            /**
                * @deprecated Use .groups instead.
                */
            offsets: any;
            /**
                * @deprecated Use .setIndex() instead.
                */
            addIndex(index: any): void;
            /**
                * @deprecated Use .addGroup() instead.
                */
            addDrawCall(start: any, count: any, indexOffset?: any): void;
            /**
                * @deprecated Use .clearGroups() instead.
                */
            clearDrawCalls(): void;
            /**
                * @deprecated Use .setAttribute() instead.
                */
            addAttribute(name: string, attribute: BufferAttribute | InterleavedBufferAttribute): BufferGeometry;
            /**
                * @deprecated Use .setAttribute() instead.
                */
            addAttribute(name: any, array: any, itemSize: any): any;
            /**
                * @deprecated Use .deleteAttribute() instead.
                */
            removeAttribute(name: string): BufferGeometry;
    }
}

declare module 'three/src/core/InterleavedBufferAttribute' {
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { InterleavedBuffer } from 'three/src/core/InterleavedBuffer';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Matrix } from 'three/src/math/Matrix3';
    export class InterleavedBufferAttribute {
            constructor(interleavedBuffer: InterleavedBuffer, itemSize: number, offset: number, normalized?: boolean);
            /**
                * @default ''
                */
            name: string;
            data: InterleavedBuffer;
            itemSize: number;
            offset: number;
            /**
                * @default false
                */
            normalized: boolean;
            get count(): number;
            get array(): ArrayLike<number>;
            set needsUpdate(value: boolean);
            readonly isInterleavedBufferAttribute: true;
            applyMatrix4(m: Matrix4): this;
            /**
                * @internal
                */
            clone(data?: object): BufferAttribute;
            getX(index: number): number;
            setX(index: number, x: number): this;
            getY(index: number): number;
            setY(index: number, y: number): this;
            getZ(index: number): number;
            setZ(index: number, z: number): this;
            getW(index: number): number;
            setW(index: number, z: number): this;
            setXY(index: number, x: number, y: number): this;
            setXYZ(index: number, x: number, y: number, z: number): this;
            setXYZW(index: number, x: number, y: number, z: number, w: number): this;
            /**
                * @internal
                */
            toJSON(data?: object): {
                    isInterleavedBufferAttribute: true;
                    itemSize: number;
                    data: string;
                    offset: number;
                    normalized: boolean;
            };
            applyNormalMatrix(matrix: Matrix): this;
            transformDirection(matrix: Matrix): this;
    }
}

declare module 'three/src/core/InstancedInterleavedBuffer' {
    import { InterleavedBuffer } from 'three/src/core/InterleavedBuffer';
    export class InstancedInterleavedBuffer extends InterleavedBuffer {
        constructor(array: ArrayLike<number>, stride: number, meshPerAttribute?: number);
        /**
          * @default 1
          */
        meshPerAttribute: number;
    }
}

declare module 'three/src/core/InterleavedBuffer' {
    import { InterleavedBufferAttribute } from 'three/src/core/InterleavedBufferAttribute';
    import { Usage } from 'three/src/constants';
    export class InterleavedBuffer {
            constructor(array: ArrayLike<number>, stride: number);
            array: ArrayLike<number>;
            stride: number;
            /**
                * @default THREE.StaticDrawUsage
                */
            usage: Usage;
            /**
                * @default { offset: number; count: number }
                */
            updateRange: {
                    offset: number;
                    count: number;
            };
            /**
                * @default 0
                */
            version: number;
            /**
                * @internal
                */
            length: number;
            /**
                * @default 0
                */
            count: number;
            needsUpdate: boolean;
            uuid: string;
            setUsage(usage: Usage): InterleavedBuffer;
            clone(data: object): InterleavedBuffer;
            copy(source: InterleavedBuffer): this;
            copyAt(index1: number, attribute: InterleavedBufferAttribute, index2: number): InterleavedBuffer;
            set(value: ArrayLike<number>, index: number): InterleavedBuffer;
            toJSON(data: object): {
                    uuid: string;
                    buffer: string;
                    type: string;
                    stride: number;
            };
    }
}

declare module 'three/src/core/InstancedBufferAttribute' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    /**
        * @internal
        */
    export namespace BufferGeometryUtils {
            /**
                * @internal
                */
            function mergeBufferGeometries(geometries: BufferGeometry[]): BufferGeometry;
            /**
                * @internal
                */
            function computeTangents(geometry: BufferGeometry): null;
            /**
                * @internal
                */
            function mergeBufferAttributes(attributes: BufferAttribute[]): BufferAttribute;
    }
    /**
        * @deprecated
        */
    export namespace GeometryUtils {
            /**
                * @deprecated Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.
                */
            function merge(geometry1: any, geometry2: any, materialIndexOffset?: any): any;
            /**
                * @deprecated Use geometry.center() instead.
                */
            function center(geometry: any): any;
    }
    export class InstancedBufferAttribute extends BufferAttribute {
            constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean, meshPerAttribute?: number);
            /**
                * @default 1
                */
            meshPerAttribute: number;
    }
}

declare module 'three/src/core/GLBufferAttribute' {
    export class GLBufferAttribute {
        constructor(buffer: WebGLBuffer, type: number, itemSize: number, elementSize: 1 | 2 | 4, count: number);
        buffer: WebGLBuffer;
        type: number;
        itemSize: number;
        elementSize: 1 | 2 | 4;
        count: number;
        version: number;
        readonly isGLBufferAttribute: true;
        set needsUpdate(value: boolean);
        setBuffer(buffer: WebGLBuffer): this;
        setType(type: number, elementSize: 1 | 2 | 4): this;
        setItemSize(itemSize: number): this;
        setCount(count: number): this;
    }
}

declare module 'three/src/core/BufferAttribute' {
    import { Usage } from 'three/src/constants';
    import { Matrix3 } from 'three/src/math/Matrix3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    export class BufferAttribute {
            constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean);
            /**
                * @default ''
                */
            name: string;
            array: ArrayLike<number>;
            itemSize: number;
            /**
                * @default THREE.StaticDrawUsage
                */
            usage: Usage;
            /**
                * @default { offset: number; count: number }
                */
            updateRange: {
                    offset: number;
                    count: number;
            };
            /**
                * @default 0
                */
            version: number;
            /**
                * @default false
                */
            normalized: boolean;
            /**
                * @default 0
                */
            count: number;
            set needsUpdate(value: boolean);
            readonly isBufferAttribute: true;
            onUploadCallback: () => void;
            onUpload(callback: () => void): this;
            setUsage(usage: Usage): this;
            clone(): this;
            copy(source: BufferAttribute): this;
            copyAt(index1: number, attribute: BufferAttribute, index2: number): this;
            copyArray(array: ArrayLike<number>): this;
            copyColorsArray(colors: Array<{
                    r: number;
                    g: number;
                    b: number;
            }>): this;
            copyVector2sArray(vectors: Array<{
                    x: number;
                    y: number;
            }>): this;
            copyVector3sArray(vectors: Array<{
                    x: number;
                    y: number;
                    z: number;
            }>): this;
            copyVector4sArray(vectors: Array<{
                    x: number;
                    y: number;
                    z: number;
                    w: number;
            }>): this;
            applyMatrix3(m: Matrix3): this;
            applyMatrix4(m: Matrix4): this;
            applyNormalMatrix(m: Matrix3): this;
            transformDirection(m: Matrix4): this;
            set(value: ArrayLike<number> | ArrayBufferView, offset?: number): this;
            getX(index: number): number;
            setX(index: number, x: number): this;
            getY(index: number): number;
            setY(index: number, y: number): this;
            getZ(index: number): number;
            setZ(index: number, z: number): this;
            getW(index: number): number;
            setW(index: number, z: number): this;
            setXY(index: number, x: number, y: number): this;
            setXYZ(index: number, x: number, y: number, z: number): this;
            setXYZW(index: number, x: number, y: number, z: number, w: number): this;
            /**
                * @internal
                */
            toJSON(): {
                    itemSize: number;
                    type: string;
                    array: number[];
                    normalized: boolean;
            };
    }
    /**
        * @deprecated THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.
        */
    export class Int8Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.
        */
    export class Uint8Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.
        */
    export class Uint8ClampedAttribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.
        */
    export class Int16Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.
        */
    export class Uint16Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.
        */
    export class Int32Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.
        */
    export class Uint32Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.
        */
    export class Float32Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @deprecated THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.
        */
    export class Float64Attribute extends BufferAttribute {
            constructor(array: any, itemSize: number);
    }
    /**
        * @internal
        */
    export class Int8BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Uint8BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Uint8ClampedBufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Int16BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Uint16BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Int32BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Uint32BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Float16BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Float32BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
    /**
        * @internal
        */
    export class Float64BufferAttribute extends BufferAttribute {
            constructor(array: Iterable<number> | ArrayLike<number> | ArrayBuffer | number, itemSize: number, normalized?: boolean);
    }
}

declare module 'three/src/core/Object3D' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Euler } from 'three/src/math/Euler';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Matrix3 } from 'three/src/math/Matrix3';
    import { Layers } from 'three/src/core/Layers';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { Scene } from 'three/src/scenes/Scene';
    import { Camera } from 'three/src/cameras/Camera';
    import { Material } from 'three/src/materials/Material';
    import { Group } from 'three/src/objects/Group';
    import { Intersection, Raycaster } from 'three/src/core/Raycaster';
    import { EventDispatcher, BaseEvent, Event } from 'three/src/core/EventDispatcher';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    export class Object3D<E extends BaseEvent = Event> extends EventDispatcher<E> {
            constructor();
            id: number;
            uuid: string;
            /**
                * @default ''
                */
            name: string;
            /**
                * @default 'Object3D'
                * @internal
                */
            type: string;
            /**
                * @default null
                */
            parent: Object3D | null;
            /**
                * @default []
                */
            children: Object3D[];
            /**
                * @default THREE.Object3D.DefaultUp.clone()
                */
            up: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            readonly position: Vector3;
            /**
                * @default new THREE.Euler()
                */
            readonly rotation: Euler;
            /**
                * @default new THREE.Quaternion()
                */
            readonly quaternion: Quaternion;
            /**
                * @default new THREE.Vector3()
                */
            readonly scale: Vector3;
            /**
                * @default new THREE.Matrix4()
                */
            readonly modelViewMatrix: Matrix4;
            /**
                * @default new THREE.Matrix3()
                */
            readonly normalMatrix: Matrix3;
            /**
                * @default new THREE.Matrix4()
                */
            matrix: Matrix4;
            /**
                * @default new THREE.Matrix4()
                */
            matrixWorld: Matrix4;
            /**
                * @default THREE.Object3D.DefaultMatrixAutoUpdate
                */
            matrixAutoUpdate: boolean;
            /**
                * @default false
                */
            matrixWorldNeedsUpdate: boolean;
            /**
                * @default new THREE.Layers()
                */
            layers: Layers;
            /**
                * @default true
                */
            visible: boolean;
            /**
                * @default false
                */
            castShadow: boolean;
            /**
                * @default false
                */
            receiveShadow: boolean;
            /**
                * @default true
                */
            frustumCulled: boolean;
            /**
                * @default 0
                */
            renderOrder: number;
            /**
                * @default []
                */
            animations: AnimationClip[];
            /**
                * @default {}
                */
            userData: {
                    [key: string]: any;
            };
            customDepthMaterial: Material;
            customDistanceMaterial: Material;
            readonly isObject3D: true;
            onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group) => void;
            onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group) => void;
            static DefaultUp: Vector3;
            static DefaultMatrixAutoUpdate: boolean;
            applyMatrix4(matrix: Matrix4): void;
            applyQuaternion(quaternion: Quaternion): this;
            setRotationFromAxisAngle(axis: Vector3, angle: number): void;
            setRotationFromEuler(euler: Euler): void;
            setRotationFromMatrix(m: Matrix4): void;
            setRotationFromQuaternion(q: Quaternion): void;
            rotateOnAxis(axis: Vector3, angle: number): this;
            rotateOnWorldAxis(axis: Vector3, angle: number): this;
            rotateX(angle: number): this;
            rotateY(angle: number): this;
            rotateZ(angle: number): this;
            translateOnAxis(axis: Vector3, distance: number): this;
            translateX(distance: number): this;
            translateY(distance: number): this;
            translateZ(distance: number): this;
            localToWorld(vector: Vector3): Vector3;
            worldToLocal(vector: Vector3): Vector3;
            lookAt(vector: Vector3 | number, y?: number, z?: number): void;
            add(...object: Object3D[]): this;
            remove(...object: Object3D[]): this;
            removeFromParent(): this;
            clear(): this;
            attach(object: Object3D): this;
            getObjectById(id: number): Object3D | undefined;
            getObjectByName(name: string): Object3D | undefined;
            getObjectByProperty(name: string, value: string): Object3D | undefined;
            getWorldPosition(target: Vector3): Vector3;
            getWorldQuaternion(target: Quaternion): Quaternion;
            getWorldScale(target: Vector3): Vector3;
            getWorldDirection(target: Vector3): Vector3;
            raycast(raycaster: Raycaster, intersects: Intersection[]): void;
            traverse(callback: (object: Object3D) => any): void;
            traverseVisible(callback: (object: Object3D) => any): void;
            traverseAncestors(callback: (object: Object3D) => any): void;
            updateMatrix(): void;
            updateMatrixWorld(force?: boolean): void;
            updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void;
            toJSON(meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
            }): any;
            clone(recursive?: boolean): this;
            copy(source: this, recursive?: boolean): this;
    }
}

declare module 'three/src/core/Raycaster' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Object3D } from 'three/src/core/Object3D';
    import { Vector2 } from 'three/src/math/Vector2';
    import { Ray } from 'three/src/math/Ray';
    import { Camera } from 'three/src/cameras/Camera';
    import { Layers } from 'three/src/core/Layers';
    export interface Face {
            a: number;
            b: number;
            c: number;
            normal: Vector3;
            materialIndex: number;
    }
    export interface Intersection<TIntersected extends Object3D = Object3D> {
            distance: number;
            distanceToRay?: number | undefined;
            point: Vector3;
            index?: number | undefined;
            face?: Face | null | undefined;
            faceIndex?: number | undefined;
            object: TIntersected;
            uv?: Vector2 | undefined;
            uv2?: Vector2 | undefined;
            instanceId?: number | undefined;
    }
    export interface RaycasterParameters {
            Mesh?: any;
            Line?: {
                    threshold: number;
            } | undefined;
            LOD?: any;
            Points?: {
                    threshold: number;
            } | undefined;
            Sprite?: any;
    }
    export class Raycaster {
            constructor(origin?: Vector3, direction?: Vector3, near?: number, far?: number);
            ray: Ray;
            /**
                * @default 0
                */
            near: number;
            /**
                * @default Infinity
                */
            far: number;
            camera: Camera;
            /**
                * @default new THREE.Layers()
                */
            layers: Layers;
            /**
                * @default { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }
                */
            params: RaycasterParameters;
            set(origin: Vector3, direction: Vector3): void;
            setFromCamera(coords: {
                    x: number;
                    y: number;
            }, camera: Camera): void;
            intersectObject<TIntersected extends Object3D>(object: Object3D, recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
            intersectObjects<TIntersected extends Object3D>(objects: Object3D[], recursive?: boolean, optionalTarget?: Array<Intersection<TIntersected>>): Array<Intersection<TIntersected>>;
    }
}

declare module 'three/src/core/Layers' {
    export class Layers {
        constructor();
        /**
          * @default 1 | 0
          */
        mask: number;
        set(channel: number): void;
        enable(channel: number): void;
        enableAll(): void;
        toggle(channel: number): void;
        disable(channel: number): void;
        disableAll(): void;
        test(layers: Layers): boolean;
        isEnabled(channel: number): boolean;
    }
}

declare module 'three/src/core/EventDispatcher' {
    export interface BaseEvent {
        type: string;
    }
    export interface Event extends BaseEvent {
        target?: any;
        [attachment: string]: any;
    }
    export type EventListener<E, T, U> = (event: E & {
        type: T;
    } & {
        target: U;
    }) => void;
    export class EventDispatcher<E extends BaseEvent = Event> {
        constructor();
        addEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): void;
        hasEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): boolean;
        removeEventListener<T extends E['type']>(type: T, listener: EventListener<E, T, this>): void;
        dispatchEvent(event: E): void;
    }
}

declare module 'three/src/core/Clock' {
    export class Clock {
            constructor(autoStart?: boolean);
            /**
                * @default true
                */
            autoStart: boolean;
            /**
                * @default 0
                */
            startTime: number;
            /**
                * @default 0
                */
            oldTime: number;
            /**
                * @default 0
                */
            elapsedTime: number;
            /**
                * @default false
                */
            running: boolean;
            start(): void;
            stop(): void;
            getElapsedTime(): number;
            getDelta(): number;
    }
}

declare module 'three/src/extras/curves/Curves' {
    export * from 'three/src/extras/curves/ArcCurve';
    export * from 'three/src/extras/curves/CatmullRomCurve3';
    export * from 'three/src/extras/curves/CubicBezierCurve';
    export * from 'three/src/extras/curves/CubicBezierCurve3';
    export * from 'three/src/extras/curves/EllipseCurve';
    export * from 'three/src/extras/curves/LineCurve';
    export * from 'three/src/extras/curves/LineCurve3';
    export * from 'three/src/extras/curves/QuadraticBezierCurve';
    export * from 'three/src/extras/curves/QuadraticBezierCurve3';
    export * from 'three/src/extras/curves/SplineCurve';
}

declare module 'three/src/extras/core/Shape' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Path } from 'three/src/extras/core/Path';
    export class Shape extends Path {
            constructor(points?: Vector2[]);
            /**
                * @default 'Shape'
                * @internal
                */
            type: string;
            uuid: string;
            /**
                * @default []
                */
            holes: Path[];
            getPointsHoles(divisions: number): Vector2[][];
            extractPoints(divisions: number): {
                    shape: Vector2[];
                    holes: Vector2[][];
            };
    }
}

declare module 'three/src/extras/core/Path' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { CurvePath } from 'three/src/extras/core/CurvePath';
    export class Path extends CurvePath<Vector2> {
            constructor(points?: Vector2[]);
            /**
                * @default 'Path'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector2()
                */
            currentPoint: Vector2;
            /**
                * @deprecated Use .setFromPoints() instead.
                */
            fromPoints(vectors: Vector2[]): this;
            setFromPoints(vectors: Vector2[]): this;
            moveTo(x: number, y: number): this;
            lineTo(x: number, y: number): this;
            quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
            bezierCurveTo(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number): this;
            splineThru(pts: Vector2[]): this;
            arc(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean): this;
            absarc(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean): this;
            ellipse(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean, aRotation: number): this;
            absellipse(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean, aRotation: number): this;
    }
}

declare module 'three/src/extras/core/ShapePath' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Shape } from 'three/src/extras/core/Shape';
    import { Color } from 'three/src/math/Color';
    export class ShapePath {
            constructor();
            /**
                * @default 'ShapePath'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color()
                */
            color: Color;
            /**
                * @default []
                */
            subPaths: any[];
            /**
                * @default null
                */
            currentPath: any;
            moveTo(x: number, y: number): this;
            lineTo(x: number, y: number): this;
            quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): this;
            bezierCurveTo(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number): this;
            splineThru(pts: Vector2[]): this;
            toShapes(isCCW: boolean, noHoles?: boolean): Shape[];
    }
}

declare module 'three/src/extras/core/CurvePath' {
    import { Curve } from 'three/src/extras/core/Curve';
    import { Vector } from 'three/src/math/Vector2';
    export class CurvePath<T extends Vector> extends Curve<T> {
            constructor();
            /**
                * @default 'CurvePath'
                * @internal
                */
            type: string;
            /**
                * @default []
                */
            curves: Array<Curve<T>>;
            /**
                * @default false
                */
            autoClose: boolean;
            add(curve: Curve<T>): void;
            closePath(): void;
            /**
                * @internal
                */
            getPoint(t: number, optionalTarget?: T): T;
            getCurveLengths(): number[];
    }
}

declare module 'three/src/extras/core/Curve' {
    import { Vector } from 'three/src/math/Vector2';
    import { Vector3 } from 'three/src/math/Vector3';
    export class Curve<T extends Vector> {
            /**
                * @default 'Curve'
                * @internal
                */
            type: string;
            /**
                * @default 200
                */
            arcLengthDivisions: number;
            getPoint(t: number, optionalTarget?: T): T;
            getPointAt(u: number, optionalTarget?: T): T;
            getPoints(divisions?: number): T[];
            getSpacedPoints(divisions?: number): T[];
            getLength(): number;
            getLengths(divisions?: number): number[];
            updateArcLengths(): void;
            getUtoTmapping(u: number, distance: number): number;
            getTangent(t: number, optionalTarget?: T): T;
            getTangentAt(u: number, optionalTarget?: T): T;
            computeFrenetFrames(segments: number, closed?: boolean): {
                    tangents: Vector3[];
                    normals: Vector3[];
                    binormals: Vector3[];
            };
            clone(): this;
            copy(source: Curve<T>): this;
            toJSON(): object;
            fromJSON(json: object): this;
            /**
                * @deprecated since r84.
                */
            static create(constructorFunc: () => void, getPointFunc: () => void): () => void;
    }
}

declare module 'three/src/extras/DataUtils' {
    export namespace DataUtils {
        function toHalfFloat(val: number): number;
    }
}

declare module 'three/src/extras/ImageUtils' {
    import { Mapping } from 'three/src/constants';
    import { Texture } from 'three/src/textures/Texture';
    export namespace ImageUtils {
            function getDataURL(image: any): string;
            let crossOrigin: string;
            /**
                * @deprecated Use THREE.TextureLoader() instead.
                */
            function loadTexture(url: string, mapping?: Mapping, onLoad?: (texture: Texture) => void, onError?: (message: string) => void): Texture;
            /**
                * @deprecated Use THREE.CubeTextureLoader() instead.
                */
            function loadTextureCube(array: string[], mapping?: Mapping, onLoad?: (texture: Texture) => void, onError?: (message: string) => void): Texture;
            function sRGBToLinear(image: any): HTMLCanvasElement | {
                    data: number[];
                    width: number;
                    height: number;
            };
    }
}

declare module 'three/src/extras/ShapeUtils' {
    export interface Vec2 {
        x: number;
        y: number;
    }
    export namespace ShapeUtils {
        function area(contour: Vec2[]): number;
        function triangulateShape(contour: Vec2[], holes: Vec2[][]): number[][];
        function isClockWise(pts: Vec2[]): boolean;
    }
}

declare module 'three/src/extras/PMREMGenerator' {
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    import { Texture } from 'three/src/textures/Texture';
    import { CubeTexture } from 'three/src/textures/CubeTexture';
    import { Scene } from 'three/src/scenes/Scene';
    export class PMREMGenerator {
        constructor(renderer: WebGLRenderer);
        fromScene(scene: Scene, sigma?: number, near?: number, far?: number): WebGLRenderTarget;
        fromEquirectangular(equirectangular: Texture, renderTarget?: WebGLRenderTarget | null): WebGLRenderTarget;
        fromCubemap(cubemap: CubeTexture, renderTarget?: WebGLRenderTarget | null): WebGLRenderTarget;
        compileCubemapShader(): void;
        compileEquirectangularShader(): void;
        dispose(): void;
    }
}

declare module 'three/src/geometries/Geometries' {
    export * from 'three/src/geometries/BoxGeometry';
    export * from 'three/src/geometries/CapsuleGeometry';
    export * from 'three/src/geometries/CircleGeometry';
    export * from 'three/src/geometries/ConeGeometry';
    export * from 'three/src/geometries/CylinderGeometry';
    export * from 'three/src/geometries/DodecahedronGeometry';
    export * from 'three/src/geometries/EdgesGeometry';
    export * from 'three/src/geometries/ExtrudeGeometry';
    export * from 'three/src/geometries/IcosahedronGeometry';
    export * from 'three/src/geometries/LatheGeometry';
    export * from 'three/src/geometries/OctahedronGeometry';
    export * from 'three/src/geometries/PlaneGeometry';
    export * from 'three/src/geometries/PolyhedronGeometry';
    export * from 'three/src/geometries/RingGeometry';
    export * from 'three/src/geometries/ShapeGeometry';
    export * from 'three/src/geometries/SphereGeometry';
    export * from 'three/src/geometries/TetrahedronGeometry';
    export * from 'three/src/geometries/TorusGeometry';
    export * from 'three/src/geometries/TorusKnotGeometry';
    export * from 'three/src/geometries/TubeGeometry';
    export * from 'three/src/geometries/WireframeGeometry';
}

declare module 'three/src/helpers/SpotLightHelper' {
    import { Light } from 'three/src/lights/Light';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Object3D } from 'three/src/core/Object3D';
    import { LineSegments } from 'three/src/objects/LineSegments';
    import { ColorRepresentation } from 'three/src/utils';
    export class SpotLightHelper extends Object3D {
        constructor(light: Light, color?: ColorRepresentation);
        light: Light;
        matrix: Matrix4;
        /**
          * @default false
          */
        matrixAutoUpdate: boolean;
        color: ColorRepresentation | undefined;
        cone: LineSegments;
        dispose(): void;
        update(): void;
    }
}

declare module 'three/src/helpers/SkeletonHelper' {
    import { Object3D } from 'three/src/core/Object3D';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Bone } from 'three/src/objects/Bone';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class SkeletonHelper extends LineSegments {
            constructor(object: Object3D);
            /**
                * @default 'SkeletonHelper'
                * @internal
                */
            type: string;
            bones: Bone[];
            root: Object3D;
            readonly isSkeletonHelper: true;
            /**
                * @internal
                */
            matrix: Matrix4;
            /**
                * @default false
                * @internal
                */
            matrixAutoUpdate: boolean;
            /**
                * @internal
                */
            getBoneList(object: Object3D): Bone[];
            /**
                * @internal
                */
            update(): void;
    }
}

declare module 'three/src/helpers/PointLightHelper' {
    import { PointLight } from 'three/src/lights/PointLight';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Object3D } from 'three/src/core/Object3D';
    import { ColorRepresentation } from 'three/src/utils';
    export class PointLightHelper extends Object3D {
            constructor(light: PointLight, sphereSize?: number, color?: ColorRepresentation);
            /**
                * @default 'PointLightHelper'
                * @internal
                */
            type: string;
            light: PointLight;
            color: ColorRepresentation | undefined;
            matrix: Matrix4;
            /**
                * @default false
                */
            matrixAutoUpdate: boolean;
            dispose(): void;
            update(): void;
    }
}

declare module 'three/src/helpers/HemisphereLightHelper' {
    import { HemisphereLight } from 'three/src/lights/HemisphereLight';
    import { Color } from 'three/src/math/Color';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { MeshBasicMaterial } from 'three/src/materials/MeshBasicMaterial';
    import { Object3D } from 'three/src/core/Object3D';
    import { ColorRepresentation } from 'three/src/utils';
    export class HemisphereLightHelper extends Object3D {
        constructor(light: HemisphereLight, size: number, color?: ColorRepresentation);
        light: HemisphereLight;
        matrix: Matrix4;
        matrixAutoUpdate: boolean;
        /**
          * @internal
          */
        material: MeshBasicMaterial;
        color: ColorRepresentation | undefined;
        dispose(): void;
        update(): void;
    }
}

declare module 'three/src/helpers/GridHelper' {
    import { ColorRepresentation } from 'three/src/utils';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class GridHelper extends LineSegments {
            constructor(size?: number, divisions?: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
            /**
                * @default 'GridHelper'
                * @internal
                */
            type: string;
            /**
                * @deprecated Colors should be specified in the constructor.
                */
            setColors(color1?: ColorRepresentation, color2?: ColorRepresentation): void;
    }
}

declare module 'three/src/helpers/PolarGridHelper' {
    import { LineSegments } from 'three/src/objects/LineSegments';
    import { ColorRepresentation } from 'three/src/utils';
    export class PolarGridHelper extends LineSegments {
        constructor(radius?: number, radials?: number, circles?: number, divisions?: number, color1?: ColorRepresentation, color2?: ColorRepresentation);
        /**
          * @default 'PolarGridHelper'
          * @internal
          */
        type: string;
    }
}

declare module 'three/src/helpers/DirectionalLightHelper' {
    import { DirectionalLight } from 'three/src/lights/DirectionalLight';
    import { Line } from 'three/src/objects/Line';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Object3D } from 'three/src/core/Object3D';
    import { ColorRepresentation } from 'three/src/utils';
    export class DirectionalLightHelper extends Object3D {
            constructor(light: DirectionalLight, size?: number, color?: ColorRepresentation);
            light: DirectionalLight;
            lightPlane: Line;
            /**
                * @internal
                */
            targetLine: Line;
            /**
                * @default undefined
                */
            color: ColorRepresentation | undefined;
            matrix: Matrix4;
            /**
                * @default false
                */
            matrixAutoUpdate: boolean;
            dispose(): void;
            update(): void;
    }
}

declare module 'three/src/helpers/CameraHelper' {
    import { Camera } from 'three/src/cameras/Camera';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class CameraHelper extends LineSegments {
        constructor(camera: Camera);
        camera: Camera;
        pointMap: {
            [id: string]: number[];
        };
        /**
          * @default 'CameraHelper'
          * @internal
          */
        type: string;
        update(): void;
        dispose(): void;
    }
}

declare module 'three/src/helpers/BoxHelper' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Object3D } from 'three/src/core/Object3D';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class BoxHelper extends LineSegments {
        constructor(object: Object3D, color?: ColorRepresentation);
        /**
          * @default 'BoxHelper'
          * @internal
          */
        type: string;
        update(object?: Object3D): void;
        setFromObject(object: Object3D): this;
    }
}

declare module 'three/src/helpers/Box3Helper' {
    import { Box3 } from 'three/src/math/Box3';
    import { Color } from 'three/src/math/Color';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class Box3Helper extends LineSegments {
        constructor(box: Box3, color?: Color);
        /**
          * @default 'Box3Helper'
          * @internal
          */
        type: string;
        box: Box3;
    }
}

declare module 'three/src/helpers/PlaneHelper' {
    import { Plane } from 'three/src/math/Plane';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class PlaneHelper extends LineSegments {
            constructor(plane: Plane, size?: number, hex?: number);
            /**
                * @default 'PlaneHelper'
                * @internal
                */
            type: string;
            plane: Plane;
            /**
                * @default 1
                */
            size: number;
            updateMatrixWorld(force?: boolean): void;
    }
}

declare module 'three/src/helpers/ArrowHelper' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Line } from 'three/src/objects/Line';
    import { Mesh } from 'three/src/objects/Mesh';
    import { Object3D } from 'three/src/core/Object3D';
    import { ColorRepresentation } from 'three/src/utils';
    export class ArrowHelper extends Object3D {
        constructor(dir?: Vector3, origin?: Vector3, length?: number, color?: ColorRepresentation, headLength?: number, headWidth?: number);
        /**
          * @default 'ArrowHelper'
          * @internal
          */
        type: string;
        line: Line;
        cone: Mesh;
        setDirection(dir: Vector3): void;
        setLength(length: number, headLength?: number, headWidth?: number): void;
        setColor(color: ColorRepresentation): void;
    }
}

declare module 'three/src/helpers/AxesHelper' {
    import { Color } from 'three/src/math/Color';
    import { LineSegments } from 'three/src/objects/LineSegments';
    export class AxesHelper extends LineSegments {
        constructor(size?: number);
        /**
          * @default 'AxesHelper'
          * @internal
          */
        type: string;
        setColors(xAxisColor: Color, yAxisColor: Color, zAxisColor: Color): this;
        dispose(): void;
    }
}

declare module 'three/src/lights/SpotLightShadow' {
    import { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera';
    import { LightShadow } from 'three/src/lights/LightShadow';
    /**
        * @internal
        */
    export class SpotLightShadow extends LightShadow {
            /**
                * @internal
                */
            camera: PerspectiveCamera;
            /**
                * @internal
                */
            readonly isSpotLightShadow: true;
            /**
                * @default 1
                * @internal
                */
            focus: number;
    }
}

declare module 'three/src/lights/SpotLight' {
    import { Color } from 'three/src/math/Color';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Object3D } from 'three/src/core/Object3D';
    import { SpotLightShadow } from 'three/src/lights/SpotLightShadow';
    import { Light } from 'three/src/lights/Light';
    import { ColorRepresentation } from 'three/src/utils';
    export class SpotLight extends Light {
            constructor(color?: ColorRepresentation, intensity?: number, distance?: number, angle?: number, penumbra?: number, decay?: number);
            /**
                * @default 'SpotLight'
                * @internal
                */
            type: string;
            /**
                * @default THREE.Object3D.DefaultUp
                */
            position: Vector3;
            /**
                * @default new THREE.Object3D()
                */
            target: Object3D;
            /**
                * @default 1
                */
            intensity: number;
            /**
                * @default 0
                */
            distance: number;
            /**
                * @default Math.PI / 3.
                */
            angle: number;
            /**
                * @default 1
                */
            decay: number;
            /**
                * @default new THREE.SpotLightShadow()
                */
            shadow: SpotLightShadow;
            power: number;
            /**
                * @default 0
                */
            penumbra: number;
            readonly isSpotLight: true;
    }
}

declare module 'three/src/lights/PointLight' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Light } from 'three/src/lights/Light';
    import { PointLightShadow } from 'three/src/lights/PointLightShadow';
    export class PointLight extends Light {
            constructor(color?: ColorRepresentation, intensity?: number, distance?: number, decay?: number);
            /**
                * @default 'PointLight'
                * @internal
                */
            type: string;
            /**
                * @default 1
                */
            intensity: number;
            /**
                * @default 0
                */
            distance: number;
            /**
                * @default 1
                */
            decay: number;
            /**
                * @default new THREE.PointLightShadow()
                */
            shadow: PointLightShadow;
            power: number;
    }
}

declare module 'three/src/lights/PointLightShadow' {
    import { PerspectiveCamera } from 'three/src/cameras/PerspectiveCamera';
    import { LightShadow } from 'three/src/lights/LightShadow';
    /**
        * @internal
        */
    export class PointLightShadow extends LightShadow {
            /**
                * @internal
                */
            camera: PerspectiveCamera;
    }
}

declare module 'three/src/lights/RectAreaLight' {
    import { Light } from 'three/src/lights/Light';
    import { ColorRepresentation } from 'three/src/utils';
    export class RectAreaLight extends Light {
            constructor(color?: ColorRepresentation, intensity?: number, width?: number, height?: number);
            /**
                * @default 'RectAreaLight'
                * @internal
                */
            type: string;
            /**
                * @default 10
                */
            width: number;
            /**
                * @default 10
                */
            height: number;
            /**
                * @default 1
                */
            intensity: number;
            power: number;
            readonly isRectAreaLight: true;
    }
}

declare module 'three/src/lights/HemisphereLight' {
    import { Color } from 'three/src/math/Color';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Light } from 'three/src/lights/Light';
    import { ColorRepresentation } from 'three/src/utils';
    export class HemisphereLight extends Light {
            constructor(skyColor?: ColorRepresentation, groundColor?: ColorRepresentation, intensity?: number);
            /**
                * @default 'HemisphereLight'
                * @internal
                */
            type: string;
            /**
                * @default THREE.Object3D.DefaultUp
                */
            position: Vector3;
            groundColor: Color;
            readonly isHemisphereLight: true;
    }
}

declare module 'three/src/lights/DirectionalLightShadow' {
    import { OrthographicCamera } from 'three/src/cameras/OrthographicCamera';
    import { LightShadow } from 'three/src/lights/LightShadow';
    /**
        * @internal
        */
    export class DirectionalLightShadow extends LightShadow {
            /**
                * @internal
                */
            camera: OrthographicCamera;
            /**
                * @internal
                */
            readonly isDirectionalLightShadow: true;
    }
}

declare module 'three/src/lights/DirectionalLight' {
    import { Object3D } from 'three/src/core/Object3D';
    import { DirectionalLightShadow } from 'three/src/lights/DirectionalLightShadow';
    import { Light } from 'three/src/lights/Light';
    import { Vector3 } from 'three/src/math/Vector3';
    import { ColorRepresentation } from 'three/src/utils';
    export class DirectionalLight extends Light {
            constructor(color?: ColorRepresentation, intensity?: number);
            /**
                * @default 'DirectionalLight'
                * @internal
                */
            type: string;
            /**
                * @default THREE.Object3D.DefaultUp
                */
            readonly position: Vector3;
            /**
                * @default new THREE.Object3D()
                */
            target: Object3D;
            /**
                * @default 1
                * @internal
                */
            intensity: number;
            /**
                * @default new THREE.DirectionalLightShadow()
                */
            shadow: DirectionalLightShadow;
            readonly isDirectionalLight: true;
    }
}

declare module 'three/src/lights/AmbientLight' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Light } from 'three/src/lights/Light';
    export class AmbientLight extends Light {
        constructor(color?: ColorRepresentation, intensity?: number);
        /**
          * @default 'AmbientLight'
          * @internal
          */
        type: string;
        readonly isAmbientLight: true;
    }
}

declare module 'three/src/lights/LightShadow' {
    import { Camera } from 'three/src/cameras/Camera';
    import { Light } from 'three/src/lights/Light';
    import { Vector2 } from 'three/src/math/Vector2';
    import { Vector4 } from 'three/src/math/Vector4';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    /**
        * @internal
        */
    export class LightShadow {
            constructor(camera: Camera);
            /**
                * @internal
                */
            camera: Camera;
            /**
                * @default 0
                * @internal
                */
            bias: number;
            /**
                * @default 0
                * @internal
                */
            normalBias: number;
            /**
                * @default 1
                * @internal
                */
            radius: number;
            /**
                * @default 8
                * @internal
                */
            blurSamples: number;
            /**
                * @default new THREE.Vector2( 512, 512 )
                * @internal
                */
            mapSize: Vector2;
            /**
                * @default null
                * @internal
                */
            map: WebGLRenderTarget;
            /**
                * @default null
                * @internal
                */
            mapPass: WebGLRenderTarget;
            /**
                * @default new THREE.Matrix4()
                * @internal
                */
            matrix: Matrix4;
            /**
                * @default true
                * @internal
                */
            autoUpdate: boolean;
            /**
                * @default false
                * @internal
                */
            needsUpdate: boolean;
            /**
                * @internal
                */
            copy(source: LightShadow): this;
            /**
                * @internal
                */
            clone(recursive?: boolean): this;
            /**
                * @internal
                */
            toJSON(): any;
            /**
                * @internal
                */
            getFrustum(): number;
            /**
                * @internal
                */
            updateMatrices(light: Light, viewportIndex?: number): void;
            /**
                * @internal
                */
            getViewport(viewportIndex: number): Vector4;
            /**
                * @internal
                */
            getFrameExtents(): Vector2;
            /**
                * @internal
                */
            dispose(): void;
    }
}

declare module 'three/src/lights/Light' {
    import { Color } from 'three/src/math/Color';
    import { LightShadow } from 'three/src/lights/LightShadow';
    import { Object3D } from 'three/src/core/Object3D';
    export class Light extends Object3D {
            constructor(hex?: number | string, intensity?: number);
            /**
                * @default 'Light'
                * @internal
                */
            type: string;
            color: Color;
            /**
                * @default 1
                */
            intensity: number;
            readonly isLight: true;
            /**
                * @internal
                */
            shadow: LightShadow;
            /**
                * @deprecated Use shadow.camera.fov instead.
                */
            shadowCameraFov: any;
            /**
                * @deprecated Use shadow.camera.left instead.
                */
            shadowCameraLeft: any;
            /**
                * @deprecated Use shadow.camera.right instead.
                */
            shadowCameraRight: any;
            /**
                * @deprecated Use shadow.camera.top instead.
                */
            shadowCameraTop: any;
            /**
                * @deprecated Use shadow.camera.bottom instead.
                */
            shadowCameraBottom: any;
            /**
                * @deprecated Use shadow.camera.near instead.
                */
            shadowCameraNear: any;
            /**
                * @deprecated Use shadow.camera.far instead.
                */
            shadowCameraFar: any;
            /**
                * @deprecated Use shadow.bias instead.
                */
            shadowBias: any;
            /**
                * @deprecated Use shadow.mapSize.width instead.
                */
            shadowMapWidth: any;
            /**
                * @deprecated Use shadow.mapSize.height instead.
                */
            shadowMapHeight: any;
            dispose(): void;
    }
}

declare module 'three/src/lights/AmbientLightProbe' {
    import { ColorRepresentation } from 'three/src/utils';
    import { LightProbe } from 'three/src/lights/LightProbe';
    export class AmbientLightProbe extends LightProbe {
        constructor(color?: ColorRepresentation, intensity?: number);
        readonly isAmbientLightProbe: true;
    }
}

declare module 'three/src/lights/HemisphereLightProbe' {
    import { ColorRepresentation } from 'three/src/utils';
    import { LightProbe } from 'three/src/lights/LightProbe';
    export class HemisphereLightProbe extends LightProbe {
        constructor(skyColor?: ColorRepresentation, groundColor?: ColorRepresentation, intensity?: number);
        readonly isHemisphereLightProbe: true;
    }
}

declare module 'three/src/lights/LightProbe' {
    import { SphericalHarmonics3 } from 'three/src/math/SphericalHarmonics3';
    import { Light } from 'three/src/lights/Light';
    export class LightProbe extends Light {
            constructor(sh?: SphericalHarmonics3, intensity?: number);
            /**
                * @default 'LightProbe'
                * @internal
                */
            type: string;
            readonly isLightProbe: true;
            /**
                * @default new THREE.SphericalHarmonics3()
                */
            sh: SphericalHarmonics3;
            /**
                * @internal
                */
            fromJSON(json: object): LightProbe;
    }
}

declare module 'three/src/loaders/AnimationLoader' {
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { Loader } from 'three/src/loaders/Loader';
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    export class AnimationLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad: (response: AnimationClip[]) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<AnimationClip[]>;
        parse(json: any): AnimationClip[];
    }
}

declare module 'three/src/loaders/CompressedTextureLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { CompressedTexture } from 'three/src/textures/CompressedTexture';
    export class CompressedTextureLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad: (texture: CompressedTexture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): CompressedTexture;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<CompressedTexture>;
    }
}

declare module 'three/src/loaders/DataTextureLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { DataTexture } from 'three/src/textures/DataTexture';
    export class DataTextureLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad: (dataTexture: DataTexture, texData: object) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): DataTexture;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<DataTexture>;
    }
}

declare module 'three/src/loaders/CubeTextureLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { CubeTexture } from 'three/src/textures/CubeTexture';
    export class CubeTextureLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(urls: string[], onLoad?: (texture: CubeTexture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): CubeTexture;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<CubeTexture>;
    }
}

declare module 'three/src/loaders/TextureLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { Texture } from 'three/src/textures/Texture';
    export class TextureLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad?: (texture: Texture) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): Texture;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Texture>;
    }
}

declare module 'three/src/loaders/ObjectLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { Object3D } from 'three/src/core/Object3D';
    import { Texture } from 'three/src/textures/Texture';
    import { Material } from 'three/src/materials/Material';
    import { AnimationClip } from 'three/src/animation/AnimationClip';
    import { InstancedBufferGeometry } from 'three/src/core/InstancedBufferGeometry';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class ObjectLoader extends Loader {
            constructor(manager?: LoadingManager);
            load(url: string, onLoad?: <ObjectType extends Object3D>(object: ObjectType) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: Error | ErrorEvent) => void): void;
            /**
                * @internal
                */
            loadAsync<ObjectType extends Object3D>(url: string, onProgress?: (event: ProgressEvent) => void): Promise<ObjectType>;
            parse<T extends Object3D>(json: any, onLoad?: (object: Object3D) => void): T;
            /**
                * @internal
                */
            parseAsync<T extends Object3D>(json: any): Promise<T>;
            parseGeometries(json: any): {
                    [key: string]: InstancedBufferGeometry | BufferGeometry;
            };
            parseMaterials(json: any, textures: Texture[]): Material[];
            parseAnimations(json: any): AnimationClip[];
            parseImages(json: any, onLoad: () => void): {
                    [key: string]: HTMLImageElement;
            };
            /**
                * @internal
                */
            parseImagesAsync(json: any): Promise<{
                    [key: string]: HTMLImageElement;
            }>;
            parseTextures(json: any, images: any): Texture[];
            parseObject<T extends Object3D>(data: any, geometries: any[], materials: Material[], animations: AnimationClip[]): T;
    }
}

declare module 'three/src/loaders/MaterialLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { Texture } from 'three/src/textures/Texture';
    import { Material } from 'three/src/materials/Material';
    export class MaterialLoader extends Loader {
            constructor(manager?: LoadingManager);
            /**
                * @default {}
                */
            textures: {
                    [key: string]: Texture;
            };
            load(url: string, onLoad: (material: Material) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: Error | ErrorEvent) => void): void;
            /**
                * @internal
                */
            loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Material>;
            setTextures(textures: {
                    [key: string]: Texture;
            }): this;
            parse(json: any): Material;
    }
}

declare module 'three/src/loaders/BufferGeometryLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { InstancedBufferGeometry } from 'three/src/core/InstancedBufferGeometry';
    export class BufferGeometryLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad: (bufferGeometry: InstancedBufferGeometry | BufferGeometry) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<InstancedBufferGeometry | BufferGeometry>;
        parse(json: any): InstancedBufferGeometry | BufferGeometry;
    }
}

declare module 'three/src/loaders/LoadingManager' {
    import { Loader } from 'three/src/loaders/Loader';
    export const DefaultLoadingManager: LoadingManager;
    /**
        * @internal
        */
    export class LoadingManager {
            constructor(onLoad?: () => void, onProgress?: (url: string, loaded: number, total: number) => void, onError?: (url: string) => void);
            /**
                * @internal
                */
            onStart?: ((url: string, loaded: number, total: number) => void) | undefined;
            /**
                * @internal
                */
            onLoad: () => void;
            /**
                * @internal
                */
            onProgress: (url: string, loaded: number, total: number) => void;
            /**
                * @internal
                */
            onError: (url: string) => void;
            /**
                * @internal
                */
            setURLModifier(callback?: (url: string) => string): this;
            /**
                * @internal
                */
            resolveURL(url: string): string;
            /**
                * @internal
                */
            itemStart(url: string): void;
            /**
                * @internal
                */
            itemEnd(url: string): void;
            /**
                * @internal
                */
            itemError(url: string): void;
            /**
                * @internal
                */
            addHandler(regex: RegExp, loader: Loader): this;
            /**
                * @internal
                */
            removeHandler(regex: RegExp): this;
            /**
                * @internal
                */
            getHandler(file: string): Loader | null;
    }
}

declare module 'three/src/loaders/ImageLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    export class ImageLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad?: (image: HTMLImageElement) => void, onProgress?: (event: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): HTMLImageElement;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<HTMLImageElement>;
    }
}

declare module 'three/src/loaders/ImageBitmapLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    export class ImageBitmapLoader extends Loader {
            constructor(manager?: LoadingManager);
            /**
                * @default { premultiplyAlpha: 'none' }
                */
            options: undefined | object;
            readonly isImageBitmapLoader: true;
            setOptions(options: object): ImageBitmapLoader;
            load(url: string, onLoad?: (response: ImageBitmap) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): any;
            /**
                * @internal
                */
            loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<ImageBitmap>;
    }
}

declare module 'three/src/loaders/FileLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    export class FileLoader extends Loader {
        constructor(manager?: LoadingManager);
        mimeType: undefined | MimeType;
        responseType: undefined | string;
        load(url: string, onLoad?: (response: string | ArrayBuffer) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): any;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<string | ArrayBuffer>;
        setMimeType(mimeType: MimeType): FileLoader;
        setResponseType(responseType: string): FileLoader;
    }
}

declare module 'three/src/loaders/Loader' {
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    export class Loader {
            constructor(manager?: LoadingManager);
            /**
                * @default 'anonymous'
                */
            crossOrigin: string;
            /**
                * @default : false
                */
            withCredentials: boolean;
            /**
                * @default ''
                */
            path: string;
            /**
                * @default ''
                */
            resourcePath: string;
            manager: LoadingManager;
            /**
                * @default {}
                */
            requestHeader: {
                    [header: string]: string;
            };
            loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any>;
            setCrossOrigin(crossOrigin: string): this;
            setWithCredentials(value: boolean): this;
            setPath(path: string): this;
            setResourcePath(resourcePath: string): this;
            setRequestHeader(requestHeader: {
                    [header: string]: string;
            }): this;
    }
}

declare module 'three/src/loaders/LoaderUtils' {
    export interface LoaderUtils {
        decodeText(array: BufferSource): string;
        extractUrlBase(url: string): string;
        resolveURL(url: string, path: string): string;
    }
    export const LoaderUtils: LoaderUtils;
}

declare module 'three/src/loaders/Cache' {
    export namespace Cache {
        let enabled: boolean;
        let files: any;
        function add(key: string, file: any): void;
        function get(key: string): any;
        function remove(key: string): void;
        function clear(): void;
    }
}

declare module 'three/src/loaders/AudioLoader' {
    import { Loader } from 'three/src/loaders/Loader';
    import { LoadingManager } from 'three/src/loaders/LoadingManager';
    export class AudioLoader extends Loader {
        constructor(manager?: LoadingManager);
        load(url: string, onLoad: (audioBuffer: AudioBuffer) => void, onProgress?: (request: ProgressEvent) => void, onError?: (event: ErrorEvent) => void): void;
        /**
          * @internal
          */
        loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<AudioBuffer>;
    }
}

declare module 'three/src/materials/Materials' {
    export * from 'three/src/materials/ShadowMaterial';
    export * from 'three/src/materials/SpriteMaterial';
    export * from 'three/src/materials/RawShaderMaterial';
    export * from 'three/src/materials/ShaderMaterial';
    export * from 'three/src/materials/PointsMaterial';
    export * from 'three/src/materials/MeshPhysicalMaterial';
    export * from 'three/src/materials/MeshStandardMaterial';
    export * from 'three/src/materials/MeshPhongMaterial';
    export * from 'three/src/materials/MeshToonMaterial';
    export * from 'three/src/materials/MeshNormalMaterial';
    export * from 'three/src/materials/MeshLambertMaterial';
    export * from 'three/src/materials/MeshDepthMaterial';
    export * from 'three/src/materials/MeshDistanceMaterial';
    export * from 'three/src/materials/MeshBasicMaterial';
    export * from 'three/src/materials/MeshMatcapMaterial';
    export * from 'three/src/materials/LineDashedMaterial';
    export * from 'three/src/materials/LineBasicMaterial';
    export * from 'three/src/materials/Material';
}

declare module 'three/src/math/interpolants/QuaternionLinearInterpolant' {
    import { Interpolant } from 'three/src/math/Interpolant';
    export class QuaternionLinearInterpolant extends Interpolant {
        constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
        /**
          * @internal
          */
        interpolate_(i1: number, t0: number, t: number, t1: number): any;
    }
}

declare module 'three/src/math/interpolants/LinearInterpolant' {
    import { Interpolant } from 'three/src/math/Interpolant';
    export class LinearInterpolant extends Interpolant {
        constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
        /**
          * @internal
          */
        interpolate_(i1: number, t0: number, t: number, t1: number): any;
    }
}

declare module 'three/src/math/interpolants/DiscreteInterpolant' {
    import { Interpolant } from 'three/src/math/Interpolant';
    export class DiscreteInterpolant extends Interpolant {
        constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
        /**
          * @internal
          */
        interpolate_(i1: number, t0: number, t: number, t1: number): any;
    }
}

declare module 'three/src/math/interpolants/CubicInterpolant' {
    import { Interpolant } from 'three/src/math/Interpolant';
    export class CubicInterpolant extends Interpolant {
        constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any);
        /**
          * @internal
          */
        interpolate_(i1: number, t0: number, t: number, t1: number): any;
    }
}

declare module 'three/src/math/Interpolant' {
    export abstract class Interpolant {
        constructor(parameterPositions: any, sampleValues: any, sampleSize: number, resultBuffer?: any);
        parameterPositions: any;
        sampleValues: any;
        valueSize: number;
        resultBuffer: any;
        evaluate(time: number): any;
    }
}

declare module 'three/src/math/Triangle' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Plane } from 'three/src/math/Plane';
    import { Box3 } from 'three/src/math/Box3';
    import { InterleavedBufferAttribute } from 'three/src/core/InterleavedBufferAttribute';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    export class Triangle {
            constructor(a?: Vector3, b?: Vector3, c?: Vector3);
            /**
                * @default new THREE.Vector3()
                */
            a: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            b: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            c: Vector3;
            set(a: Vector3, b: Vector3, c: Vector3): Triangle;
            setFromPointsAndIndices(points: Vector3[], i0: number, i1: number, i2: number): this;
            setFromAttributeAndIndices(attribute: BufferAttribute | InterleavedBufferAttribute, i0: number, i1: number, i2: number): this;
            clone(): this;
            copy(triangle: Triangle): this;
            getArea(): number;
            getMidpoint(target: Vector3): Vector3;
            getNormal(target: Vector3): Vector3;
            getPlane(target: Plane): Plane;
            getBarycoord(point: Vector3, target: Vector3): Vector3;
            getUV(point: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2;
            containsPoint(point: Vector3): boolean;
            intersectsBox(box: Box3): boolean;
            isFrontFacing(direction: Vector3): boolean;
            closestPointToPoint(point: Vector3, target: Vector3): Vector3;
            equals(triangle: Triangle): boolean;
            static getNormal(a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
            static getBarycoord(point: Vector3, a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3;
            static containsPoint(point: Vector3, a: Vector3, b: Vector3, c: Vector3): boolean;
            static getUV(point: Vector3, p1: Vector3, p2: Vector3, p3: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2;
            static isFrontFacing(a: Vector3, b: Vector3, c: Vector3, direction: Vector3): boolean;
    }
}

declare module 'three/src/math/Spherical' {
    import { Vector3 } from 'three/src/math/Vector3';
    export class Spherical {
            constructor(radius?: number, phi?: number, theta?: number);
            /**
                * @default 1
                */
            radius: number;
            /**
                * @default 0
                */
            phi: number;
            /**
                * @default 0
                */
            theta: number;
            set(radius: number, phi: number, theta: number): this;
            clone(): this;
            copy(other: Spherical): this;
            makeSafe(): this;
            setFromVector3(v: Vector3): this;
            setFromCartesianCoords(x: number, y: number, z: number): this;
    }
}

declare module 'three/src/math/Cylindrical' {
    import { Vector3 } from 'three/src/math/Vector3';
    export class Cylindrical {
            constructor(radius?: number, theta?: number, y?: number);
            /**
                * @default 1
                */
            radius: number;
            /**
                * @default 0
                */
            theta: number;
            /**
                * @default 0
                */
            y: number;
            clone(): this;
            copy(other: Cylindrical): this;
            set(radius: number, theta: number, y: number): this;
            setFromVector3(vec3: Vector3): this;
            setFromCartesianCoords(x: number, y: number, z: number): this;
    }
}

declare module 'three/src/math/Plane' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Sphere } from 'three/src/math/Sphere';
    import { Line3 } from 'three/src/math/Line3';
    import { Box3 } from 'three/src/math/Box3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Matrix3 } from 'three/src/math/Matrix3';
    export class Plane {
            constructor(normal?: Vector3, constant?: number);
            /**
                * @default new THREE.Vector3( 1, 0, 0 )
                */
            normal: Vector3;
            /**
                * @default 0
                */
            constant: number;
            readonly isPlane: true;
            set(normal: Vector3, constant: number): Plane;
            setComponents(x: number, y: number, z: number, w: number): Plane;
            setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane;
            setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane;
            clone(): this;
            copy(plane: Plane): this;
            normalize(): Plane;
            negate(): Plane;
            distanceToPoint(point: Vector3): number;
            distanceToSphere(sphere: Sphere): number;
            projectPoint(point: Vector3, target: Vector3): Vector3;
            /**
                * @internal
                */
            orthoPoint(point: Vector3, target: Vector3): Vector3;
            intersectLine(line: Line3, target: Vector3): Vector3 | null;
            intersectsLine(line: Line3): boolean;
            intersectsBox(box: Box3): boolean;
            intersectsSphere(sphere: Sphere): boolean;
            coplanarPoint(target: Vector3): Vector3;
            applyMatrix4(matrix: Matrix4, optionalNormalMatrix?: Matrix3): Plane;
            translate(offset: Vector3): Plane;
            equals(plane: Plane): boolean;
            /**
                * @deprecated Use .intersectsLine() instead.
                */
            isIntersectionLine(l: any): any;
    }
}

declare module 'three/src/math/Frustum' {
    import { Plane } from 'three/src/math/Plane';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Object3D } from 'three/src/core/Object3D';
    import { Sprite } from 'three/src/objects/Sprite';
    import { Sphere } from 'three/src/math/Sphere';
    import { Box3 } from 'three/src/math/Box3';
    import { Vector3 } from 'three/src/math/Vector3';
    export class Frustum {
        constructor(p0?: Plane, p1?: Plane, p2?: Plane, p3?: Plane, p4?: Plane, p5?: Plane);
        planes: Plane[];
        set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane): Frustum;
        clone(): this;
        copy(frustum: Frustum): this;
        setFromProjectionMatrix(m: Matrix4): this;
        intersectsObject(object: Object3D): boolean;
        intersectsSprite(sprite: Sprite): boolean;
        intersectsSphere(sphere: Sphere): boolean;
        intersectsBox(box: Box3): boolean;
        containsPoint(point: Vector3): boolean;
    }
}

declare module 'three/src/math/Sphere' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Box3 } from 'three/src/math/Box3';
    import { Plane } from 'three/src/math/Plane';
    import { Matrix4 } from 'three/src/math/Matrix4';
    export class Sphere {
            constructor(center?: Vector3, radius?: number);
            /**
                * @default new Vector3()
                */
            center: Vector3;
            /**
                * @default 1
                */
            radius: number;
            set(center: Vector3, radius: number): Sphere;
            setFromPoints(points: Vector3[], optionalCenter?: Vector3): Sphere;
            clone(): this;
            copy(sphere: Sphere): this;
            expandByPoint(point: Vector3): this;
            isEmpty(): boolean;
            makeEmpty(): this;
            containsPoint(point: Vector3): boolean;
            distanceToPoint(point: Vector3): number;
            intersectsSphere(sphere: Sphere): boolean;
            intersectsBox(box: Box3): boolean;
            intersectsPlane(plane: Plane): boolean;
            clampPoint(point: Vector3, target: Vector3): Vector3;
            getBoundingBox(target: Box3): Box3;
            applyMatrix4(matrix: Matrix4): Sphere;
            translate(offset: Vector3): Sphere;
            equals(sphere: Sphere): boolean;
            union(sphere: Sphere): this;
            /**
                * @deprecated Use .isEmpty() instead.
                */
            empty(): any;
    }
}

declare module 'three/src/math/Ray' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Sphere } from 'three/src/math/Sphere';
    import { Plane } from 'three/src/math/Plane';
    import { Box3 } from 'three/src/math/Box3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    export class Ray {
            constructor(origin?: Vector3, direction?: Vector3);
            /**
                * @default new THREE.Vector3()
                */
            origin: Vector3;
            /**
                * @default new THREE.Vector3( 0, 0, - 1 )
                */
            direction: Vector3;
            set(origin: Vector3, direction: Vector3): Ray;
            clone(): this;
            copy(ray: Ray): this;
            at(t: number, target: Vector3): Vector3;
            lookAt(v: Vector3): Ray;
            recast(t: number): Ray;
            closestPointToPoint(point: Vector3, target: Vector3): Vector3;
            distanceToPoint(point: Vector3): number;
            distanceSqToPoint(point: Vector3): number;
            distanceSqToSegment(v0: Vector3, v1: Vector3, optionalPointOnRay?: Vector3, optionalPointOnSegment?: Vector3): number;
            intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null;
            intersectsSphere(sphere: Sphere): boolean;
            distanceToPlane(plane: Plane): number;
            intersectPlane(plane: Plane, target: Vector3): Vector3 | null;
            intersectsPlane(plane: Plane): boolean;
            intersectBox(box: Box3, target: Vector3): Vector3 | null;
            intersectsBox(box: Box3): boolean;
            intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3): Vector3 | null;
            applyMatrix4(matrix4: Matrix4): Ray;
            equals(ray: Ray): boolean;
            /**
                * @deprecated Use .intersectsBox() instead.
                */
            isIntersectionBox(b: any): any;
            /**
                * @deprecated Use .intersectsPlane() instead.
                */
            isIntersectionPlane(p: any): any;
            /**
                * @deprecated Use .intersectsSphere() instead.
                */
            isIntersectionSphere(s: any): any;
    }
}

declare module 'three/src/math/Matrix4' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Euler } from 'three/src/math/Euler';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { Matrix, Matrix3 } from 'three/src/math/Matrix3';
    export type Matrix4Tuple = [
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number
    ];
    export class Matrix4 implements Matrix {
            constructor();
            /**
                * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                */
            elements: number[];
            set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): Matrix4;
            identity(): Matrix4;
            clone(): Matrix4;
            copy(m: Matrix4): this;
            copyPosition(m: Matrix4): Matrix4;
            extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
            makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
            extractRotation(m: Matrix4): Matrix4;
            makeRotationFromEuler(euler: Euler): Matrix4;
            makeRotationFromQuaternion(q: Quaternion): Matrix4;
            lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4;
            multiply(m: Matrix4): Matrix4;
            premultiply(m: Matrix4): Matrix4;
            multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4;
            /**
                * @deprecated This method has been removed completely.
                */
            multiplyToArray(a: Matrix4, b: Matrix4, r: number[]): Matrix4;
            multiplyScalar(s: number): Matrix4;
            determinant(): number;
            transpose(): Matrix4;
            setPosition(v: Vector3 | number, y?: number, z?: number): Matrix4;
            invert(): Matrix4;
            scale(v: Vector3): Matrix4;
            getMaxScaleOnAxis(): number;
            makeTranslation(x: number, y: number, z: number): Matrix4;
            makeRotationX(theta: number): Matrix4;
            makeRotationY(theta: number): Matrix4;
            makeRotationZ(theta: number): Matrix4;
            makeRotationAxis(axis: Vector3, angle: number): Matrix4;
            makeScale(x: number, y: number, z: number): Matrix4;
            makeShear(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number): Matrix4;
            compose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
            decompose(translation: Vector3, rotation: Quaternion, scale: Vector3): Matrix4;
            makePerspective(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix4;
            makePerspective(fov: number, aspect: number, near: number, far: number): Matrix4;
            makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): Matrix4;
            equals(matrix: Matrix4): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix4;
            toArray(array?: number[], offset?: number): number[];
            toArray(array?: Matrix4Tuple, offset?: 0): Matrix4Tuple;
            toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            setFromMatrix3(m: Matrix3): Matrix4;
            /**
                * @deprecated Use .copyPosition() instead.
                */
            extractPosition(m: Matrix4): Matrix4;
            /**
                * @deprecated Use .makeRotationFromQuaternion() instead.
                */
            setRotationFromQuaternion(q: Quaternion): Matrix4;
            /**
                * @deprecated Use vector.applyMatrix4( matrix ) instead.
                */
            multiplyVector3(v: any): any;
            /**
                * @deprecated Use vector.applyMatrix4( matrix ) instead.
                */
            multiplyVector4(v: any): any;
            /**
                * @deprecated This method has been removed completely.
                */
            multiplyVector3Array(array: number[]): number[];
            /**
                * @deprecated Use Vector3.transformDirection( matrix ) instead.
                */
            rotateAxis(v: any): void;
            /**
                * @deprecated Use vector.applyMatrix4( matrix ) instead.
                */
            crossVector(v: any): void;
            /**
                * @deprecated Use .toArray() instead.
                */
            flattenToArrayOffset(array: number[], offset: number): number[];
            /**
                * @deprecated Use .invert() instead.
                */
            getInverse(matrix: Matrix): Matrix;
    }
}

declare module 'three/src/math/Matrix3' {
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Vector3 } from 'three/src/math/Vector3';
    export type Matrix3Tuple = [
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number,
            number
    ];
    export interface Matrix {
            elements: number[];
            identity(): Matrix;
            copy(m: this): this;
            multiplyScalar(s: number): Matrix;
            determinant(): number;
            transpose(): Matrix;
            invert(): Matrix;
            clone(): Matrix;
    }
    export class Matrix3 implements Matrix {
            constructor();
            /**
                * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
                */
            elements: number[];
            set(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number): Matrix3;
            identity(): Matrix3;
            clone(): this;
            copy(m: Matrix3): this;
            extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix3;
            setFromMatrix4(m: Matrix4): Matrix3;
            multiplyScalar(s: number): Matrix3;
            determinant(): number;
            invert(): Matrix3;
            transpose(): Matrix3;
            getNormalMatrix(matrix4: Matrix4): Matrix3;
            transposeIntoArray(r: number[]): Matrix3;
            setUvTransform(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number): Matrix3;
            scale(sx: number, sy: number): Matrix3;
            rotate(theta: number): Matrix3;
            translate(tx: number, ty: number): Matrix3;
            equals(matrix: Matrix3): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): Matrix3;
            toArray(array?: number[], offset?: number): number[];
            toArray(array?: Matrix3Tuple, offset?: 0): Matrix3Tuple;
            toArray(array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            multiply(m: Matrix3): Matrix3;
            premultiply(m: Matrix3): Matrix3;
            multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3;
            /**
                * @deprecated Use vector.applyMatrix3( matrix ) instead.
                */
            multiplyVector3(vector: Vector3): any;
            /**
                * @deprecated This method has been removed completely.
                */
            multiplyVector3Array(a: any): any;
            /**
                * @deprecated Use .invert() instead.
                */
            getInverse(matrix: Matrix4, throwOnDegenerate?: boolean): Matrix3;
            /**
                * @deprecated Use .invert() instead.
                */
            getInverse(matrix: Matrix): Matrix;
            /**
                * @deprecated Use .toArray() instead.
                */
            flattenToArrayOffset(array: number[], offset: number): number[];
    }
}

declare module 'three/src/math/Box3' {
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Object3D } from 'three/src/core/Object3D';
    import { Sphere } from 'three/src/math/Sphere';
    import { Plane } from 'three/src/math/Plane';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Triangle } from 'three/src/math/Triangle';
    export class Box3 {
            constructor(min?: Vector3, max?: Vector3);
            /**
                * @default new THREE.Vector3( + Infinity, + Infinity, + Infinity )
                */
            min: Vector3;
            /**
                * @default new THREE.Vector3( - Infinity, - Infinity, - Infinity )
                */
            max: Vector3;
            readonly isBox3: true;
            set(min: Vector3, max: Vector3): this;
            setFromArray(array: ArrayLike<number>): this;
            setFromBufferAttribute(bufferAttribute: BufferAttribute): this;
            setFromPoints(points: Vector3[]): this;
            setFromCenterAndSize(center: Vector3, size: Vector3): this;
            setFromObject(object: Object3D, precise?: boolean): this;
            clone(): this;
            copy(box: Box3): this;
            makeEmpty(): this;
            isEmpty(): boolean;
            getCenter(target: Vector3): Vector3;
            getSize(target: Vector3): Vector3;
            expandByPoint(point: Vector3): this;
            expandByVector(vector: Vector3): this;
            expandByScalar(scalar: number): this;
            expandByObject(object: Object3D, precise?: boolean): this;
            containsPoint(point: Vector3): boolean;
            containsBox(box: Box3): boolean;
            getParameter(point: Vector3, target: Vector3): Vector3;
            intersectsBox(box: Box3): boolean;
            intersectsSphere(sphere: Sphere): boolean;
            intersectsPlane(plane: Plane): boolean;
            intersectsTriangle(triangle: Triangle): boolean;
            clampPoint(point: Vector3, target: Vector3): Vector3;
            distanceToPoint(point: Vector3): number;
            getBoundingSphere(target: Sphere): Sphere;
            intersect(box: Box3): this;
            union(box: Box3): this;
            applyMatrix4(matrix: Matrix4): this;
            translate(offset: Vector3): this;
            equals(box: Box3): boolean;
            /**
                * @deprecated Use .isEmpty() instead.
                */
            empty(): any;
            /**
                * @deprecated Use .intersectsBox() instead.
                */
            isIntersectionBox(b: any): any;
            /**
                * @deprecated Use .intersectsSphere() instead.
                */
            isIntersectionSphere(s: any): any;
    }
}

declare module 'three/src/math/Box2' {
    import { Vector2 } from 'three/src/math/Vector2';
    export class Box2 {
            constructor(min?: Vector2, max?: Vector2);
            /**
                * @default new THREE.Vector2( + Infinity, + Infinity )
                */
            min: Vector2;
            /**
                * @default new THREE.Vector2( - Infinity, - Infinity )
                */
            max: Vector2;
            set(min: Vector2, max: Vector2): Box2;
            setFromPoints(points: Vector2[]): Box2;
            setFromCenterAndSize(center: Vector2, size: Vector2): Box2;
            clone(): this;
            copy(box: Box2): this;
            makeEmpty(): Box2;
            isEmpty(): boolean;
            getCenter(target: Vector2): Vector2;
            getSize(target: Vector2): Vector2;
            expandByPoint(point: Vector2): Box2;
            expandByVector(vector: Vector2): Box2;
            expandByScalar(scalar: number): Box2;
            containsPoint(point: Vector2): boolean;
            containsBox(box: Box2): boolean;
            getParameter(point: Vector2, target: Vector2): Vector2;
            intersectsBox(box: Box2): boolean;
            clampPoint(point: Vector2, target: Vector2): Vector2;
            distanceToPoint(point: Vector2): number;
            intersect(box: Box2): Box2;
            union(box: Box2): Box2;
            translate(offset: Vector2): Box2;
            equals(box: Box2): boolean;
            /**
                * @deprecated Use .isEmpty() instead.
                */
            empty(): any;
            /**
                * @deprecated Use .intersectsBox() instead.
                */
            isIntersectionBox(b: any): any;
    }
}

declare module 'three/src/math/Line3' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    export class Line3 {
            constructor(start?: Vector3, end?: Vector3);
            /**
                * @default new THREE.Vector3()
                */
            start: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            end: Vector3;
            set(start?: Vector3, end?: Vector3): Line3;
            clone(): this;
            copy(line: Line3): this;
            getCenter(target: Vector3): Vector3;
            delta(target: Vector3): Vector3;
            distanceSq(): number;
            distance(): number;
            at(t: number, target: Vector3): Vector3;
            closestPointToPointParameter(point: Vector3, clampToLine?: boolean): number;
            closestPointToPoint(point: Vector3, clampToLine: boolean, target: Vector3): Vector3;
            applyMatrix4(matrix: Matrix4): Line3;
            equals(line: Line3): boolean;
    }
}

declare module 'three/src/math/Euler' {
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { Vector3 } from 'three/src/math/Vector3';
    export class Euler {
            constructor(x?: number, y?: number, z?: number, order?: string);
            /**
                * @default 0
                */
            x: number;
            /**
                * @default 0
                */
            y: number;
            /**
                * @default 0
                */
            z: number;
            /**
                * @default THREE.Euler.DefaultOrder
                */
            order: string;
            readonly isEuler: true;
            /**
                * @internal
                */
            _onChangeCallback: () => void;
            set(x: number, y: number, z: number, order?: string): Euler;
            clone(): this;
            copy(euler: Euler): this;
            setFromRotationMatrix(m: Matrix4, order?: string, update?: boolean): Euler;
            setFromQuaternion(q: Quaternion, order?: string, update?: boolean): Euler;
            setFromVector3(v: Vector3, order?: string): Euler;
            reorder(newOrder: string): Euler;
            equals(euler: Euler): boolean;
            fromArray(xyzo: any[]): Euler;
            toArray(array?: number[], offset?: number): number[];
            /**
                * @internal
                */
            _onChange(callback: () => void): this;
            /**
                * @internal
                */
            static RotationOrders: string[];
            /**
                * @internal
                */
            static DefaultOrder: string;
    }
}

declare module 'three/src/math/Vector4' {
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { Vector } from 'three/src/math/Vector2';
    export type Vector4Tuple = [
            number,
            number,
            number,
            number
    ];
    export class Vector4 implements Vector {
            constructor(x?: number, y?: number, z?: number, w?: number);
            /**
                * @default 0
                */
            x: number;
            /**
                * @default 0
                */
            y: number;
            /**
                * @default 0
                */
            z: number;
            /**
                * @default 0
                */
            w: number;
            width: number;
            height: number;
            readonly isVector4: true;
            set(x: number, y: number, z: number, w: number): this;
            setScalar(scalar: number): this;
            setX(x: number): this;
            setY(y: number): this;
            setZ(z: number): this;
            setW(w: number): this;
            setComponent(index: number, value: number): this;
            getComponent(index: number): number;
            clone(): this;
            copy(v: Vector4): this;
            add(v: Vector4): this;
            addScalar(scalar: number): this;
            addVectors(a: Vector4, b: Vector4): this;
            addScaledVector(v: Vector4, s: number): this;
            sub(v: Vector4): this;
            subScalar(s: number): this;
            subVectors(a: Vector4, b: Vector4): this;
            multiply(v: Vector4): this;
            multiplyScalar(s: number): this;
            applyMatrix4(m: Matrix4): this;
            divideScalar(s: number): this;
            setAxisAngleFromQuaternion(q: Quaternion): this;
            setAxisAngleFromRotationMatrix(m: Matrix4): this;
            min(v: Vector4): this;
            max(v: Vector4): this;
            clamp(min: Vector4, max: Vector4): this;
            clampScalar(min: number, max: number): this;
            floor(): this;
            ceil(): this;
            round(): this;
            roundToZero(): this;
            negate(): this;
            dot(v: Vector4): number;
            lengthSq(): number;
            length(): number;
            manhattanLength(): number;
            normalize(): this;
            setLength(length: number): this;
            lerp(v: Vector4, alpha: number): this;
            lerpVectors(v1: Vector4, v2: Vector4, alpha: number): this;
            equals(v: Vector4): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
            toArray(array?: number[], offset?: number): number[];
            toArray(array?: Vector4Tuple, offset?: 0): Vector4Tuple;
            toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            fromBufferAttribute(attribute: BufferAttribute, index: number): this;
            random(): this;
    }
}

declare module 'three/src/math/Vector3' {
    import { Euler } from 'three/src/math/Euler';
    import { Matrix3 } from 'three/src/math/Matrix3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Quaternion } from 'three/src/math/Quaternion';
    import { Camera } from 'three/src/cameras/Camera';
    import { Spherical } from 'three/src/math/Spherical';
    import { Cylindrical } from 'three/src/math/Cylindrical';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { InterleavedBufferAttribute } from 'three/src/core/InterleavedBufferAttribute';
    import { Vector } from 'three/src/math/Vector2';
    export type Vector3Tuple = [
            number,
            number,
            number
    ];
    export class Vector3 implements Vector {
            constructor(x?: number, y?: number, z?: number);
            /**
                * @default 0
                */
            x: number;
            /**
                * @default 0
                */
            y: number;
            /**
                * @default 0
                */
            z: number;
            readonly isVector3: true;
            set(x: number, y: number, z: number): this;
            setScalar(scalar: number): this;
            setX(x: number): Vector3;
            setY(y: number): Vector3;
            setZ(z: number): Vector3;
            setComponent(index: number, value: number): this;
            getComponent(index: number): number;
            clone(): this;
            copy(v: Vector3): this;
            add(v: Vector3): this;
            addScalar(s: number): this;
            addScaledVector(v: Vector3, s: number): this;
            addVectors(a: Vector3, b: Vector3): this;
            sub(a: Vector3): this;
            subScalar(s: number): this;
            subVectors(a: Vector3, b: Vector3): this;
            multiply(v: Vector3): this;
            multiplyScalar(s: number): this;
            multiplyVectors(a: Vector3, b: Vector3): this;
            applyEuler(euler: Euler): this;
            applyAxisAngle(axis: Vector3, angle: number): this;
            applyMatrix3(m: Matrix3): this;
            applyNormalMatrix(m: Matrix3): this;
            applyMatrix4(m: Matrix4): this;
            applyQuaternion(q: Quaternion): this;
            project(camera: Camera): this;
            unproject(camera: Camera): this;
            transformDirection(m: Matrix4): this;
            divide(v: Vector3): this;
            divideScalar(s: number): this;
            min(v: Vector3): this;
            max(v: Vector3): this;
            clamp(min: Vector3, max: Vector3): this;
            clampScalar(min: number, max: number): this;
            clampLength(min: number, max: number): this;
            floor(): this;
            ceil(): this;
            round(): this;
            roundToZero(): this;
            negate(): this;
            dot(v: Vector3): number;
            lengthSq(): number;
            length(): number;
            /**
                * @deprecated Use .manhattanLength() instead.
                */
            lengthManhattan(): number;
            manhattanLength(): number;
            manhattanDistanceTo(v: Vector3): number;
            normalize(): this;
            setLength(l: number): this;
            lerp(v: Vector3, alpha: number): this;
            lerpVectors(v1: Vector3, v2: Vector3, alpha: number): this;
            cross(a: Vector3): this;
            crossVectors(a: Vector3, b: Vector3): this;
            projectOnVector(v: Vector3): this;
            projectOnPlane(planeNormal: Vector3): this;
            reflect(vector: Vector3): this;
            angleTo(v: Vector3): number;
            distanceTo(v: Vector3): number;
            distanceToSquared(v: Vector3): number;
            /**
                * @deprecated Use .manhattanDistanceTo() instead.
                */
            distanceToManhattan(v: Vector3): number;
            setFromSpherical(s: Spherical): this;
            setFromSphericalCoords(r: number, phi: number, theta: number): this;
            setFromCylindrical(s: Cylindrical): this;
            setFromCylindricalCoords(radius: number, theta: number, y: number): this;
            setFromMatrixPosition(m: Matrix4): this;
            setFromMatrixScale(m: Matrix4): this;
            setFromMatrixColumn(matrix: Matrix4, index: number): this;
            setFromMatrix3Column(matrix: Matrix3, index: number): this;
            setFromEuler(e: Euler): this;
            equals(v: Vector3): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
            toArray(array?: number[], offset?: number): number[];
            toArray(array?: Vector3Tuple, offset?: 0): Vector3Tuple;
            toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            fromBufferAttribute(attribute: BufferAttribute | InterleavedBufferAttribute, index: number): this;
            random(): this;
            randomDirection(): this;
    }
}

declare module 'three/src/math/Vector2' {
    import { Matrix3 } from 'three/src/math/Matrix3';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    export type Vector2Tuple = [
            number,
            number
    ];
    export interface Vector {
            setComponent(index: number, value: number): this;
            getComponent(index: number): number;
            set(...args: number[]): this;
            setScalar(scalar: number): this;
            copy(v: Vector): this;
            add(v: Vector): this;
            addVectors(a: Vector, b: Vector): this;
            addScaledVector(vector: Vector, scale: number): this;
            addScalar(scalar: number): this;
            sub(v: Vector): this;
            subVectors(a: Vector, b: Vector): this;
            multiplyScalar(s: number): this;
            divideScalar(s: number): this;
            negate(): this;
            dot(v: Vector): number;
            lengthSq(): number;
            length(): number;
            normalize(): this;
            distanceTo?(v: Vector): number;
            distanceToSquared?(v: Vector): number;
            setLength(l: number): this;
            lerp(v: Vector, alpha: number): this;
            equals(v: Vector): boolean;
            clone(): Vector;
    }
    export class Vector2 implements Vector {
            constructor(x?: number, y?: number);
            /**
                * @default 0
                */
            x: number;
            /**
                * @default 0
                */
            y: number;
            width: number;
            height: number;
            readonly isVector2: true;
            set(x: number, y: number): this;
            setScalar(scalar: number): this;
            setX(x: number): this;
            setY(y: number): this;
            setComponent(index: number, value: number): this;
            getComponent(index: number): number;
            clone(): this;
            copy(v: Vector2): this;
            add(v: Vector2, w?: Vector2): this;
            addScalar(s: number): this;
            addVectors(a: Vector2, b: Vector2): this;
            addScaledVector(v: Vector2, s: number): this;
            sub(v: Vector2): this;
            subScalar(s: number): this;
            subVectors(a: Vector2, b: Vector2): this;
            multiply(v: Vector2): this;
            multiplyScalar(scalar: number): this;
            divide(v: Vector2): this;
            divideScalar(s: number): this;
            applyMatrix3(m: Matrix3): this;
            min(v: Vector2): this;
            max(v: Vector2): this;
            clamp(min: Vector2, max: Vector2): this;
            clampScalar(min: number, max: number): this;
            clampLength(min: number, max: number): this;
            floor(): this;
            ceil(): this;
            round(): this;
            roundToZero(): this;
            negate(): this;
            dot(v: Vector2): number;
            cross(v: Vector2): number;
            lengthSq(): number;
            length(): number;
            /**
                * @deprecated Use .manhattanLength() instead.
                */
            lengthManhattan(): number;
            manhattanLength(): number;
            normalize(): this;
            angle(): number;
            distanceTo(v: Vector2): number;
            distanceToSquared(v: Vector2): number;
            /**
                * @deprecated Use .manhattanDistanceTo() instead.
                */
            distanceToManhattan(v: Vector2): number;
            manhattanDistanceTo(v: Vector2): number;
            setLength(length: number): this;
            lerp(v: Vector2, alpha: number): this;
            lerpVectors(v1: Vector2, v2: Vector2, alpha: number): this;
            equals(v: Vector2): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
            toArray(array?: number[], offset?: number): number[];
            toArray(array?: Vector2Tuple, offset?: 0): Vector2Tuple;
            toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            fromBufferAttribute(attribute: BufferAttribute, index: number): this;
            rotateAround(center: Vector2, angle: number): this;
            random(): this;
    }
}

declare module 'three/src/math/Quaternion' {
    import { Euler } from 'three/src/math/Euler';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Matrix4 } from 'three/src/math/Matrix4';
    export class Quaternion {
            constructor(x?: number, y?: number, z?: number, w?: number);
            /**
                * @default 0
                */
            x: number;
            /**
                * @default 0
                */
            y: number;
            /**
                * @default 0
                */
            z: number;
            /**
                * @default 1
                */
            w: number;
            readonly isQuaternion: true;
            set(x: number, y: number, z: number, w: number): Quaternion;
            clone(): this;
            copy(q: Quaternion): this;
            setFromEuler(euler: Euler, update?: boolean): Quaternion;
            setFromAxisAngle(axis: Vector3, angle: number): Quaternion;
            setFromRotationMatrix(m: Matrix4): Quaternion;
            setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion;
            angleTo(q: Quaternion): number;
            rotateTowards(q: Quaternion, step: number): Quaternion;
            identity(): Quaternion;
            invert(): Quaternion;
            conjugate(): Quaternion;
            dot(v: Quaternion): number;
            lengthSq(): number;
            length(): number;
            normalize(): Quaternion;
            multiply(q: Quaternion): Quaternion;
            premultiply(q: Quaternion): Quaternion;
            multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion;
            slerp(qb: Quaternion, t: number): Quaternion;
            slerpQuaternions(qa: Quaternion, qb: Quaternion, t: number): Quaternion;
            equals(v: Quaternion): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
            toArray(array?: number[], offset?: number): number[];
            toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            /**
                * @internal
                */
            _onChange(callback: () => void): Quaternion;
            /**
                * @internal
                */
            _onChangeCallback: () => void;
            static slerpFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number, t: number): Quaternion;
            static multiplyQuaternionsFlat(dst: number[], dstOffset: number, src0: number[], srcOffset: number, src1: number[], stcOffset1: number): number[];
            static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: number): number;
            /**
                * @deprecated Use vector.applyQuaternion( quaternion ) instead.
                */
            multiplyVector3(v: any): any;
            /**
                * @deprecated Use .invert() instead.
                */
            inverse(): Quaternion;
            random(): Quaternion;
    }
}

declare module 'three/src/math/Color' {
    import { ColorRepresentation } from 'three/src/utils';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    export interface HSL {
            h: number;
            s: number;
            l: number;
    }
    /**
        * @internal
        */
    export function SRGBToLinear(c: number): number;
    export class Color {
            constructor(color?: ColorRepresentation);
            constructor(r: number, g: number, b: number);
            readonly isColor: true;
            /**
                * @default 1
                */
            r: number;
            /**
                * @default 1
                */
            g: number;
            /**
                * @default 1
                */
            b: number;
            set(color: ColorRepresentation): Color;
            setScalar(scalar: number): Color;
            setHex(hex: number): Color;
            setRGB(r: number, g: number, b: number): Color;
            setHSL(h: number, s: number, l: number): Color;
            setStyle(style: string): Color;
            setColorName(style: string): Color;
            clone(): this;
            copy(color: Color): this;
            copySRGBToLinear(color: Color): Color;
            copyLinearToSRGB(color: Color): Color;
            convertSRGBToLinear(): Color;
            convertLinearToSRGB(): Color;
            getHex(): number;
            getHexString(): string;
            getHSL(target: HSL): HSL;
            getStyle(): string;
            offsetHSL(h: number, s: number, l: number): this;
            add(color: Color): this;
            addColors(color1: Color, color2: Color): this;
            addScalar(s: number): this;
            sub(color: Color): this;
            multiply(color: Color): this;
            multiplyScalar(s: number): this;
            lerp(color: Color, alpha: number): this;
            lerpColors(color1: Color, color2: Color, alpha: number): this;
            lerpHSL(color: Color, alpha: number): this;
            equals(color: Color): boolean;
            fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
            toArray(array?: number[], offset?: number): number[];
            toArray(xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
            fromBufferAttribute(attribute: BufferAttribute, index: number): this;
            /**
                * @internal
                */
            static NAMES: Record<string, number>;
    }
}

declare module 'three/src/math/SphericalHarmonics3' {
    import { Vector3 } from 'three/src/math/Vector3';
    export class SphericalHarmonics3 {
        constructor();
        /**
          * @default [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(),
        new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]
          */
        coefficients: Vector3[];
        readonly isSphericalHarmonics3: true;
        set(coefficients: Vector3[]): SphericalHarmonics3;
        zero(): SphericalHarmonics3;
        add(sh: SphericalHarmonics3): SphericalHarmonics3;
        addScaledSH(sh: SphericalHarmonics3, s: number): SphericalHarmonics3;
        scale(s: number): SphericalHarmonics3;
        lerp(sh: SphericalHarmonics3, alpha: number): SphericalHarmonics3;
        equals(sh: SphericalHarmonics3): boolean;
        copy(sh: SphericalHarmonics3): SphericalHarmonics3;
        clone(): this;
        fromArray(array: number[] | ArrayLike<number>, offset?: number): this;
        toArray(array?: number[], offset?: number): number[];
        toArray(array: ArrayLike<number>, offset?: number): ArrayLike<number>;
        getAt(normal: Vector3, target: Vector3): Vector3;
        getIrradianceAt(normal: Vector3, target: Vector3): Vector3;
        static getBasisAt(normal: Vector3, shBasis: number[]): void;
    }
}

declare module 'three/src/math/MathUtils' {
    import { Quaternion } from 'three/src/math/Quaternion';
    export const DEG2RAD: number;
    export const RAD2DEG: number;
    export function generateUUID(): string;
    export function clamp(value: number, min: number, max: number): number;
    export function euclideanModulo(n: number, m: number): number;
    export function mapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number;
    export function smoothstep(x: number, min: number, max: number): number;
    export function smootherstep(x: number, min: number, max: number): number;
    /**
        * @deprecated Use Math.random()
        */
    export function random16(): number;
    export function randInt(low: number, high: number): number;
    export function randFloat(low: number, high: number): number;
    export function randFloatSpread(range: number): number;
    export function seededRandom(seed?: number): number;
    export function degToRad(degrees: number): number;
    export function radToDeg(radians: number): number;
    export function isPowerOfTwo(value: number): boolean;
    export function inverseLerp(x: number, y: number, t: number): number;
    export function lerp(x: number, y: number, t: number): number;
    export function damp(x: number, y: number, lambda: number, dt: number): number;
    export function pingpong(x: number, length?: number): number;
    /**
        * @deprecated Use .floorPowerOfTwo()
        */
    export function nearestPowerOfTwo(value: number): number;
    /**
        * @deprecated Use .ceilPowerOfTwo()
        */
    export function nextPowerOfTwo(value: number): number;
    export function floorPowerOfTwo(value: number): number;
    export function ceilPowerOfTwo(value: number): number;
    export function setQuaternionFromProperEuler(q: Quaternion, a: number, b: number, c: number, order: string): void;
}

declare module 'three/src/objects/Sprite' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Raycaster } from 'three/src/core/Raycaster';
    import { Object3D } from 'three/src/core/Object3D';
    import { Intersection } from 'three/src/core/Raycaster';
    import { SpriteMaterial } from 'three/src/materials/Materials';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class Sprite extends Object3D {
            constructor(material?: SpriteMaterial);
            /**
                * @internal
                */
            type: 'Sprite';
            readonly isSprite: true;
            /**
                * @internal
                */
            geometry: BufferGeometry;
            material: SpriteMaterial;
            center: Vector2;
            raycast(raycaster: Raycaster, intersects: Intersection[]): void;
            copy(source: this): this;
    }
}

declare module 'three/src/objects/LOD' {
    import { Object3D } from 'three/src/core/Object3D';
    import { Raycaster } from 'three/src/core/Raycaster';
    import { Camera } from 'three/src/cameras/Camera';
    import { Intersection } from 'three/src/core/Raycaster';
    export class LOD extends Object3D {
            constructor();
            /**
                * @internal
                */
            type: 'LOD';
            levels: Array<{
                    distance: number;
                    object: Object3D;
            }>;
            autoUpdate: boolean;
            readonly isLOD: true;
            addLevel(object: Object3D, distance?: number): this;
            getCurrentLevel(): number;
            getObjectForDistance(distance: number): Object3D | null;
            raycast(raycaster: Raycaster, intersects: Intersection[]): void;
            update(camera: Camera): void;
            toJSON(meta: any): any;
            /**
                * @deprecated Use .levels instead.
                */
            objects: any[];
    }
}

declare module 'three/src/objects/InstancedMesh' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Material } from 'three/src/materials/Material';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { InstancedBufferAttribute } from 'three/src/core/InstancedBufferAttribute';
    import { Mesh } from 'three/src/objects/Mesh';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Color } from 'three/src/math/Color';
    export class InstancedMesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Mesh<TGeometry, TMaterial> {
        constructor(geometry: TGeometry | undefined, material: TMaterial | undefined, count: number);
        count: number;
        instanceColor: null | InstancedBufferAttribute;
        instanceMatrix: InstancedBufferAttribute;
        readonly isInstancedMesh: true;
        getColorAt(index: number, color: Color): void;
        getMatrixAt(index: number, matrix: Matrix4): void;
        setColorAt(index: number, color: Color): void;
        setMatrixAt(index: number, matrix: Matrix4): void;
        dispose(): void;
    }
}

declare module 'three/src/objects/SkinnedMesh' {
    import { Material } from 'three/src/materials/Material';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Skeleton } from 'three/src/objects/Skeleton';
    import { Mesh } from 'three/src/objects/Mesh';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class SkinnedMesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Mesh<TGeometry, TMaterial> {
        constructor(geometry?: TGeometry, material?: TMaterial, useVertexTexture?: boolean);
        bindMode: string;
        bindMatrix: Matrix4;
        bindMatrixInverse: Matrix4;
        skeleton: Skeleton;
        readonly isSkinnedMesh: true;
        bind(skeleton: Skeleton, bindMatrix?: Matrix4): void;
        pose(): void;
        normalizeSkinWeights(): void;
        /**
          * @internal
          */
        updateMatrixWorld(force?: boolean): void;
        boneTransform(index: number, target: Vector3): Vector3;
    }
}

declare module 'three/src/objects/Skeleton' {
    import { Bone } from 'three/src/objects/Bone';
    import { Matrix4 } from 'three/src/math/Matrix4';
    import { DataTexture } from 'three/src/textures/DataTexture';
    export class Skeleton {
            constructor(bones: Bone[], boneInverses?: Matrix4[]);
            /**
                * @internal
                */
            uuid: string;
            bones: Bone[];
            boneInverses: Matrix4[];
            boneMatrices: Float32Array;
            boneTexture: null | DataTexture;
            boneTextureSize: number;
            /**
                * @internal
                */
            frame: number;
            /**
                * @internal
                */
            init(): void;
            calculateInverses(): void;
            computeBoneTexture(): this;
            pose(): void;
            update(): void;
            clone(): Skeleton;
            getBoneByName(name: string): undefined | Bone;
            dispose(): void;
            /**
                * @deprecated This property has been removed completely.
                */
            useVertexTexture: boolean;
    }
}

declare module 'three/src/objects/Bone' {
    import { Object3D } from 'three/src/core/Object3D';
    export class Bone extends Object3D {
        constructor();
        readonly isBone: true;
        type: 'Bone';
    }
}

declare module 'three/src/objects/Mesh' {
    import { Material } from 'three/src/materials/Material';
    import { Raycaster } from 'three/src/core/Raycaster';
    import { Object3D } from 'three/src/core/Object3D';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Intersection } from 'three/src/core/Raycaster';
    export class Mesh<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
        constructor(geometry?: TGeometry, material?: TMaterial);
        geometry: TGeometry;
        material: TMaterial;
        morphTargetInfluences?: number[] | undefined;
        morphTargetDictionary?: {
            [key: string]: number;
        } | undefined;
        readonly isMesh: true;
        /**
          * @internal
          */
        type: string;
        updateMorphTargets(): void;
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
    }
}

declare module 'three/src/objects/LineSegments' {
    import { Material } from 'three/src/materials/Material';
    import { Line } from 'three/src/objects/Line';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export const LineStrip: number;
    export const LinePieces: number;
    export class LineSegments<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Line<TGeometry, TMaterial> {
        constructor(geometry?: TGeometry, material?: TMaterial);
        /**
          * @default 'LineSegments'
          * @internal
          */
        type: 'LineSegments' | string;
        readonly isLineSegments: true;
    }
}

declare module 'three/src/objects/LineLoop' {
    import { Line } from 'three/src/objects/Line';
    import { Material } from 'three/src/materials/Material';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class LineLoop<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Line<TGeometry, TMaterial> {
        constructor(geometry?: TGeometry, material?: TMaterial);
        /**
          * @internal
          */
        type: 'LineLoop';
        readonly isLineLoop: true;
    }
}

declare module 'three/src/objects/Line' {
    import { Material } from 'three/src/materials/Material';
    import { Raycaster } from 'three/src/core/Raycaster';
    import { Object3D } from 'three/src/core/Object3D';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Intersection } from 'three/src/core/Raycaster';
    export class Line<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
        constructor(geometry?: TGeometry, material?: TMaterial);
        geometry: TGeometry;
        material: TMaterial;
        /**
          * @internal
          */
        type: 'Line' | 'LineLoop' | 'LineSegments' | string;
        readonly isLine: true;
        morphTargetInfluences?: number[] | undefined;
        morphTargetDictionary?: {
            [key: string]: number;
        } | undefined;
        computeLineDistances(): this;
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
        updateMorphTargets(): void;
    }
}

declare module 'three/src/objects/Points' {
    import { Material } from 'three/src/materials/Material';
    import { Raycaster } from 'three/src/core/Raycaster';
    import { Object3D } from 'three/src/core/Object3D';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Intersection } from 'three/src/core/Raycaster';
    export class Points<TGeometry extends BufferGeometry = BufferGeometry, TMaterial extends Material | Material[] = Material | Material[]> extends Object3D {
        constructor(geometry?: TGeometry, material?: TMaterial);
        /**
          * @internal
          */
        type: 'Points';
        morphTargetInfluences?: number[] | undefined;
        morphTargetDictionary?: {
            [key: string]: number;
        } | undefined;
        readonly isPoints: true;
        geometry: TGeometry;
        material: TMaterial;
        raycast(raycaster: Raycaster, intersects: Intersection[]): void;
        updateMorphTargets(): void;
    }
}

declare module 'three/src/objects/Group' {
    import { Object3D } from 'three/src/core/Object3D';
    export class Group extends Object3D {
        constructor();
        type: 'Group';
        readonly isGroup: true;
    }
}

declare module 'three/src/renderers/WebGLMultisampleRenderTarget' {
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    /**
      * @deprecated THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.
      */
    export class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
    }
}

declare module 'three/src/renderers/WebGLCubeRenderTarget' {
    import { WebGLRenderTargetOptions, WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { Texture } from 'three/src/textures/Texture';
    import { CubeTexture } from 'three/src/textures/CubeTexture';
    export class WebGLCubeRenderTarget extends WebGLRenderTarget {
        constructor(size: number, options?: WebGLRenderTargetOptions);
        /**
          * @internal
          */
        texture: CubeTexture;
        fromEquirectangularTexture(renderer: WebGLRenderer, texture: Texture): this;
        clear(renderer: WebGLRenderer, color: boolean, depth: boolean, stencil: boolean): void;
    }
}

declare module 'three/src/renderers/WebGLMultipleRenderTargets' {
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { Texture } from 'three/src/textures/Texture';
    import { WebGLRenderTargetOptions } from 'three/src/renderers/WebGLRenderTarget';
    export class WebGLMultipleRenderTargets extends EventDispatcher {
            texture: Texture[];
            readonly isWebGLMultipleRenderTargets = true;
            constructor(width: number, height: number, count: number, options?: WebGLRenderTargetOptions);
            /**
                * @internal
                */
            setSize(width: number, height: number, depth?: number): this;
            /**
                * @internal
                */
            copy(source: WebGLMultipleRenderTargets): this;
            /**
                * @internal
                */
            clone(): this;
            /**
                * @internal
                */
            dispose(): void;
            /**
                * @internal
                */
            setTexture(texture: Texture): void;
    }
}

declare module 'three/src/renderers/WebGLRenderTarget' {
    import { Vector4 } from 'three/src/math/Vector4';
    import { Texture } from 'three/src/textures/Texture';
    import { DepthTexture } from 'three/src/textures/DepthTexture';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { Wrapping, TextureFilter, TextureDataType, TextureEncoding } from 'three/src/constants';
    export interface WebGLRenderTargetOptions {
            wrapS?: Wrapping | undefined;
            wrapT?: Wrapping | undefined;
            magFilter?: TextureFilter | undefined;
            minFilter?: TextureFilter | undefined;
            format?: number | undefined;
            type?: TextureDataType | undefined;
            anisotropy?: number | undefined;
            depthBuffer?: boolean | undefined;
            stencilBuffer?: boolean | undefined;
            generateMipmaps?: boolean | undefined;
            depthTexture?: DepthTexture | undefined;
            encoding?: TextureEncoding | undefined;
    }
    export class WebGLRenderTarget extends EventDispatcher {
            constructor(width: number, height: number, options?: WebGLRenderTargetOptions);
            /**
                * @internal
                */
            uuid: string;
            width: number;
            height: number;
            /**
                * @internal
                */
            depth: number;
            scissor: Vector4;
            /**
                * @default false
                */
            scissorTest: boolean;
            viewport: Vector4;
            texture: Texture;
            /**
                * @default true
                */
            depthBuffer: boolean;
            /**
                * @default true
                */
            stencilBuffer: boolean;
            /**
                * @default null
                */
            depthTexture: DepthTexture;
            /**
                * @default 0
                */
            samples: number;
            readonly isWebGLRenderTarget: true;
            /**
                * @deprecated Use texture.wrapS instead.
                */
            wrapS: any;
            /**
                * @deprecated Use texture.wrapT instead.
                */
            wrapT: any;
            /**
                * @deprecated Use texture.magFilter instead.
                */
            magFilter: any;
            /**
                * @deprecated Use texture.minFilter instead.
                */
            minFilter: any;
            /**
                * @deprecated Use texture.anisotropy instead.
                */
            anisotropy: any;
            /**
                * @deprecated Use texture.offset instead.
                */
            offset: any;
            /**
                * @deprecated Use texture.repeat instead.
                */
            repeat: any;
            /**
                * @deprecated Use texture.format instead.
                */
            format: any;
            /**
                * @deprecated Use texture.type instead.
                */
            type: any;
            /**
                * @deprecated Use texture.generateMipmaps instead.
                */
            generateMipmaps: any;
            setSize(width: number, height: number, depth?: number): void;
            clone(): this;
            copy(source: WebGLRenderTarget): this;
            dispose(): void;
    }
}

declare module 'three/src/renderers/WebGLRenderer' {
    import { Scene } from 'three/src/scenes/Scene';
    import { Camera } from 'three/src/cameras/Camera';
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLInfo } from 'three/src/renderers/webgl/WebGLInfo';
    import { WebGLShadowMap } from 'three/src/renderers/webgl/WebGLShadowMap';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { WebGLProperties } from 'three/src/renderers/webgl/WebGLProperties';
    import { WebGLRenderLists } from 'three/src/renderers/webgl/WebGLRenderLists';
    import { WebGLState } from 'three/src/renderers/webgl/WebGLState';
    import { Vector2 } from 'three/src/math/Vector2';
    import { Vector4 } from 'three/src/math/Vector4';
    import { Color } from 'three/src/math/Color';
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    import { WebGLMultipleRenderTargets } from 'three/src/renderers/WebGLMultipleRenderTargets';
    import { Object3D } from 'three/src/core/Object3D';
    import { Material } from 'three/src/materials/Material';
    import { ToneMapping, ShadowMapType, CullFace, TextureEncoding } from 'three/src/constants';
    import { WebXRManager } from 'three/src/renderers/webxr/WebXRManager';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Texture } from 'three/src/textures/Texture';
    import { Data3DTexture } from 'three/src/textures/Data3DTexture';
    import { XRAnimationLoopCallback } from 'three/src/renderers/webxr/WebXR';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Box3 } from 'three/src/math/Box3';
    import { DataArrayTexture } from 'three/src/textures/DataArrayTexture';
    import { ColorRepresentation } from 'three/src/utils';
    export interface Renderer {
            domElement: HTMLCanvasElement;
            render(scene: Object3D, camera: Camera): void;
            setSize(width: number, height: number, updateStyle?: boolean): void;
    }
    export interface OffscreenCanvas extends EventTarget {
    }
    export interface WebGLRendererParameters {
            canvas?: HTMLCanvasElement | OffscreenCanvas | undefined;
            context?: WebGLRenderingContext | undefined;
            precision?: string | undefined;
            alpha?: boolean | undefined;
            premultipliedAlpha?: boolean | undefined;
            antialias?: boolean | undefined;
            stencil?: boolean | undefined;
            preserveDrawingBuffer?: boolean | undefined;
            powerPreference?: string | undefined;
            depth?: boolean | undefined;
            logarithmicDepthBuffer?: boolean | undefined;
            failIfMajorPerformanceCaveat?: boolean | undefined;
    }
    export interface WebGLDebug {
            checkShaderErrors: boolean;
    }
    export class WebGLRenderer implements Renderer {
            constructor(parameters?: WebGLRendererParameters);
            /**
                * @default document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' )
                */
            domElement: HTMLCanvasElement;
            /**
                * @internal
                */
            context: WebGLRenderingContext;
            /**
                * @default true
                */
            autoClear: boolean;
            /**
                * @default true
                */
            autoClearColor: boolean;
            /**
                * @default true
                */
            autoClearDepth: boolean;
            /**
                * @default true
                */
            autoClearStencil: boolean;
            /**
                * @default { checkShaderErrors: true }
                */
            debug: WebGLDebug;
            /**
                * @default true
                */
            sortObjects: boolean;
            /**
                * @default []
                */
            clippingPlanes: any[];
            /**
                * @default false
                */
            localClippingEnabled: boolean;
            extensions: WebGLExtensions;
            /**
                * @default THREE.LinearEncoding
                */
            outputEncoding: TextureEncoding;
            /**
                * @default false
                */
            physicallyCorrectLights: boolean;
            /**
                * @default THREE.NoToneMapping
                */
            toneMapping: ToneMapping;
            /**
                * @default 1
                */
            toneMappingExposure: number;
            info: WebGLInfo;
            shadowMap: WebGLShadowMap;
            /**
                * @internal
                */
            pixelRatio: number;
            capabilities: WebGLCapabilities;
            properties: WebGLProperties;
            renderLists: WebGLRenderLists;
            state: WebGLState;
            xr: WebXRManager;
            getContext(): WebGLRenderingContext;
            getContextAttributes(): any;
            forceContextLoss(): void;
            forceContextRestore(): void;
            /**
                * @deprecated Use .capabilities.getMaxAnisotropy() instead.
                */
            getMaxAnisotropy(): number;
            /**
                * @deprecated Use .capabilities.precision instead.
                */
            getPrecision(): string;
            getPixelRatio(): number;
            setPixelRatio(value: number): void;
            getDrawingBufferSize(target: Vector2): Vector2;
            /**
                * @internal
                */
            setDrawingBufferSize(width: number, height: number, pixelRatio: number): void;
            getSize(target: Vector2): Vector2;
            setSize(width: number, height: number, updateStyle?: boolean): void;
            getCurrentViewport(target: Vector4): Vector4;
            getViewport(target: Vector4): Vector4;
            setViewport(x: Vector4 | number, y?: number, width?: number, height?: number): void;
            getScissor(target: Vector4): Vector4;
            setScissor(x: Vector4 | number, y?: number, width?: number, height?: number): void;
            getScissorTest(): boolean;
            setScissorTest(enable: boolean): void;
            setOpaqueSort(method: (a: any, b: any) => number): void;
            setTransparentSort(method: (a: any, b: any) => number): void;
            getClearColor(target: Color): Color;
            setClearColor(color: ColorRepresentation, alpha?: number): void;
            getClearAlpha(): number;
            setClearAlpha(alpha: number): void;
            clear(color?: boolean, depth?: boolean, stencil?: boolean): void;
            clearColor(): void;
            clearDepth(): void;
            clearStencil(): void;
            /**
                * @internal
                */
            clearTarget(renderTarget: WebGLRenderTarget, color: boolean, depth: boolean, stencil: boolean): void;
            /**
                * @deprecated Use .state.reset() instead.
                */
            resetGLState(): void;
            dispose(): void;
            /**
                * @internal
                */
            renderBufferDirect(camera: Camera, scene: Scene, geometry: BufferGeometry, material: Material, object: Object3D, geometryGroup: any): void;
            setAnimationLoop(callback: XRAnimationLoopCallback | null): void;
            /**
                * @deprecated Use .setAnimationLoop() instead.
                */
            animate(callback: () => void): void;
            compile(scene: Object3D, camera: Camera): void;
            render(scene: Object3D, camera: Camera): void;
            getActiveCubeFace(): number;
            getActiveMipmapLevel(): number;
            getRenderTarget(): WebGLRenderTarget | null;
            /**
                * @deprecated Use .getRenderTarget() instead.
                */
            getCurrentRenderTarget(): WebGLRenderTarget | null;
            setRenderTarget(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets | null, activeCubeFace?: number, activeMipmapLevel?: number): void;
            readRenderTargetPixels(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets, x: number, y: number, width: number, height: number, buffer: any, activeCubeFaceIndex?: number): void;
            copyFramebufferToTexture(position: Vector2, texture: Texture, level?: number): void;
            copyTextureToTexture(position: Vector2, srcTexture: Texture, dstTexture: Texture, level?: number): void;
            copyTextureToTexture3D(sourceBox: Box3, position: Vector3, srcTexture: Texture, dstTexture: Data3DTexture | DataArrayTexture, level?: number): void;
            initTexture(texture: Texture): void;
            resetState(): void;
            /**
                * @deprecated Use .xr instead.
                */
            vr: boolean;
            /**
                * @deprecated Use .shadowMap.enabled instead.
                */
            shadowMapEnabled: boolean;
            /**
                * @deprecated Use .shadowMap.type instead.
                */
            shadowMapType: ShadowMapType;
            /**
                * @deprecated Use .shadowMap.cullFace instead.
                */
            shadowMapCullFace: CullFace;
            /**
                * @deprecated Use .extensions.get( 'OES_texture_float' ) instead.
                */
            supportsFloatTextures(): any;
            /**
                * @deprecated Use .extensions.get( 'OES_texture_half_float' ) instead.
                */
            supportsHalfFloatTextures(): any;
            /**
                * @deprecated Use .extensions.get( 'OES_standard_derivatives' ) instead.
                */
            supportsStandardDerivatives(): any;
            /**
                * @deprecated Use .extensions.get( 'WEBGL_compressed_texture_s3tc' ) instead.
                */
            supportsCompressedTextureS3TC(): any;
            /**
                * @deprecated Use .extensions.get( 'WEBGL_compressed_texture_pvrtc' ) instead.
                */
            supportsCompressedTexturePVRTC(): any;
            /**
                * @deprecated Use .extensions.get( 'EXT_blend_minmax' ) instead.
                */
            supportsBlendMinMax(): any;
            /**
                * @deprecated Use .capabilities.vertexTextures instead.
                */
            supportsVertexTextures(): any;
            /**
                * @deprecated Use .extensions.get( 'ANGLE_instanced_arrays' ) instead.
                */
            supportsInstancedArrays(): any;
            /**
                * @deprecated Use .setScissorTest() instead.
                */
            enableScissorTest(boolean: any): any;
    }
}

declare module 'three/src/renderers/WebGL1Renderer' {
    import { WebGLRenderer, WebGLRendererParameters } from 'three/src/renderers/WebGLRenderer';
    export class WebGL1Renderer extends WebGLRenderer {
        constructor(parameters?: WebGLRendererParameters);
        readonly isWebGL1Renderer: true;
    }
}

declare module 'three/src/renderers/WebGL3DRenderTarget' {
    import { Data3DTexture } from 'three/src/textures/Data3DTexture';
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    export class WebGL3DRenderTarget extends WebGLRenderTarget {
        constructor(width: number, height: number, depth: number);
        depth: number;
        texture: Data3DTexture;
        /**
          * @internal
          */
        readonly isWebGL3DRenderTarget: true;
    }
}

declare module 'three/src/renderers/WebGLArrayRenderTarget' {
    import { DataArrayTexture } from 'three/src/textures/DataArrayTexture';
    import { WebGLRenderTarget } from 'three/src/renderers/WebGLRenderTarget';
    export class WebGLArrayRenderTarget extends WebGLRenderTarget {
        constructor(width: number, height: number, depth: number);
        depth: number;
        texture: DataArrayTexture;
        /**
          * @internal
          */
        readonly isWebGLArrayRenderTarget: true;
    }
}

declare module 'three/src/renderers/shaders/ShaderLib' {
    import { IUniform } from 'three/src/renderers/shaders/UniformsLib';
    export interface Shader {
        uniforms: {
            [uniform: string]: IUniform;
        };
        vertexShader: string;
        fragmentShader: string;
    }
    export let ShaderLib: {
        [name: string]: Shader;
        basic: Shader;
        lambert: Shader;
        phong: Shader;
        standard: Shader;
        matcap: Shader;
        points: Shader;
        dashed: Shader;
        depth: Shader;
        normal: Shader;
        sprite: Shader;
        background: Shader;
        cube: Shader;
        equirect: Shader;
        distanceRGBA: Shader;
        shadow: Shader;
        physical: Shader;
    };
}

declare module 'three/src/renderers/shaders/UniformsLib' {
    export interface IUniform<TValue = any> {
        value: TValue;
    }
    export let UniformsLib: {
        common: {
            diffuse: IUniform;
            opacity: IUniform;
            map: IUniform;
            uvTransform: IUniform;
            uv2Transform: IUniform;
            alphaMap: IUniform;
        };
        specularmap: {
            specularMap: IUniform;
        };
        envmap: {
            envMap: IUniform;
            flipEnvMap: IUniform;
            reflectivity: IUniform;
            refractionRatio: IUniform;
            maxMipLevel: IUniform;
        };
        aomap: {
            aoMap: IUniform;
            aoMapIntensity: IUniform;
        };
        lightmap: {
            lightMap: IUniform;
            lightMapIntensity: IUniform;
        };
        emissivemap: {
            emissiveMap: IUniform;
        };
        bumpmap: {
            bumpMap: IUniform;
            bumpScale: IUniform;
        };
        normalmap: {
            normalMap: IUniform;
            normalScale: IUniform;
        };
        displacementmap: {
            displacementMap: IUniform;
            displacementScale: IUniform;
            displacementBias: IUniform;
        };
        roughnessmap: {
            roughnessMap: IUniform;
        };
        metalnessmap: {
            metalnessMap: IUniform;
        };
        gradientmap: {
            gradientMap: IUniform;
        };
        fog: {
            fogDensity: IUniform;
            fogNear: IUniform;
            fogFar: IUniform;
            fogColor: IUniform;
        };
        lights: {
            ambientLightColor: IUniform;
            directionalLights: {
                value: any[];
                properties: {
                    direction: {};
                    color: {};
                };
            };
            directionalLightShadows: {
                value: any[];
                properties: {
                    shadowBias: {};
                    shadowNormalBias: {};
                    shadowRadius: {};
                    shadowMapSize: {};
                };
            };
            directionalShadowMap: IUniform;
            directionalShadowMatrix: IUniform;
            spotLights: {
                value: any[];
                properties: {
                    color: {};
                    position: {};
                    direction: {};
                    distance: {};
                    coneCos: {};
                    penumbraCos: {};
                    decay: {};
                };
            };
            spotLightShadows: {
                value: any[];
                properties: {
                    shadowBias: {};
                    shadowNormalBias: {};
                    shadowRadius: {};
                    shadowMapSize: {};
                };
            };
            spotShadowMap: IUniform;
            spotShadowMatrix: IUniform;
            pointLights: {
                value: any[];
                properties: {
                    color: {};
                    position: {};
                    decay: {};
                    distance: {};
                };
            };
            pointLightShadows: {
                value: any[];
                properties: {
                    shadowBias: {};
                    shadowNormalBias: {};
                    shadowRadius: {};
                    shadowMapSize: {};
                };
            };
            pointShadowMap: IUniform;
            pointShadowMatrix: IUniform;
            hemisphereLights: {
                value: any[];
                properties: {
                    direction: {};
                    skycolor: {};
                    groundColor: {};
                };
            };
            rectAreaLights: {
                value: any[];
                properties: {
                    color: {};
                    position: {};
                    width: {};
                    height: {};
                };
            };
        };
        points: {
            diffuse: IUniform;
            opacity: IUniform;
            size: IUniform;
            scale: IUniform;
            map: IUniform;
            uvTransform: IUniform;
        };
    };
}

declare module 'three/src/renderers/shaders/UniformsUtils' {
    /**
        * @internal
        */
    export function cloneUniforms(uniforms_src: any): any;
    /**
        * @internal
        */
    export function mergeUniforms(uniforms: any[]): any;
    export namespace UniformsUtils {
            export { mergeUniforms as merge, cloneUniforms as clone };
    }
}

declare module 'three/src/renderers/shaders/ShaderChunk' {
    export let ShaderChunk: {
        [name: string]: string;
        alphamap_fragment: string;
        alphamap_pars_fragment: string;
        alphatest_fragment: string;
        aomap_fragment: string;
        aomap_pars_fragment: string;
        begin_vertex: string;
        beginnormal_vertex: string;
        bsdfs: string;
        bumpmap_pars_fragment: string;
        clipping_planes_fragment: string;
        clipping_planes_pars_fragment: string;
        clipping_planes_pars_vertex: string;
        clipping_planes_vertex: string;
        color_fragment: string;
        color_pars_fragment: string;
        color_pars_vertex: string;
        color_vertex: string;
        common: string;
        cube_frag: string;
        cube_vert: string;
        cube_uv_reflection_fragment: string;
        defaultnormal_vertex: string;
        depth_frag: string;
        depth_vert: string;
        distanceRGBA_frag: string;
        distanceRGBA_vert: string;
        displacementmap_vertex: string;
        displacementmap_pars_vertex: string;
        emissivemap_fragment: string;
        emissivemap_pars_fragment: string;
        encodings_pars_fragment: string;
        encodings_fragment: string;
        envmap_fragment: string;
        envmap_common_pars_fragment: string;
        envmap_pars_fragment: string;
        envmap_pars_vertex: string;
        envmap_vertex: string;
        equirect_frag: string;
        equirect_vert: string;
        fog_fragment: string;
        fog_pars_fragment: string;
        linedashed_frag: string;
        linedashed_vert: string;
        lightmap_fragment: string;
        lightmap_pars_fragment: string;
        lights_lambert_vertex: string;
        lights_pars_begin: string;
        envmap_physical_pars_fragment: string;
        lights_pars_map: string;
        lights_phong_fragment: string;
        lights_phong_pars_fragment: string;
        lights_physical_fragment: string;
        lights_physical_pars_fragment: string;
        lights_fragment_begin: string;
        lights_fragment_maps: string;
        lights_fragment_end: string;
        logdepthbuf_fragment: string;
        logdepthbuf_pars_fragment: string;
        logdepthbuf_pars_vertex: string;
        logdepthbuf_vertex: string;
        map_fragment: string;
        map_pars_fragment: string;
        map_particle_fragment: string;
        map_particle_pars_fragment: string;
        meshbasic_frag: string;
        meshbasic_vert: string;
        meshlambert_frag: string;
        meshlambert_vert: string;
        meshphong_frag: string;
        meshphong_vert: string;
        meshphysical_frag: string;
        meshphysical_vert: string;
        metalnessmap_fragment: string;
        metalnessmap_pars_fragment: string;
        morphnormal_vertex: string;
        morphtarget_pars_vertex: string;
        morphtarget_vertex: string;
        normal_flip: string;
        normal_frag: string;
        normal_fragment_begin: string;
        normal_fragment_maps: string;
        normal_vert: string;
        normalmap_pars_fragment: string;
        clearcoat_normal_fragment_begin: string;
        clearcoat_normal_fragment_maps: string;
        clearcoat_pars_fragment: string;
        packing: string;
        points_frag: string;
        points_vert: string;
        shadow_frag: string;
        shadow_vert: string;
        premultiplied_alpha_fragment: string;
        project_vertex: string;
        roughnessmap_fragment: string;
        roughnessmap_pars_fragment: string;
        shadowmap_pars_fragment: string;
        shadowmap_pars_vertex: string;
        shadowmap_vertex: string;
        shadowmask_pars_fragment: string;
        skinbase_vertex: string;
        skinning_pars_vertex: string;
        skinning_vertex: string;
        skinnormal_vertex: string;
        specularmap_fragment: string;
        specularmap_pars_fragment: string;
        tonemapping_fragment: string;
        tonemapping_pars_fragment: string;
        uv2_pars_fragment: string;
        uv2_pars_vertex: string;
        uv2_vertex: string;
        uv_pars_fragment: string;
        uv_pars_vertex: string;
        uv_vertex: string;
        worldpos_vertex: string;
    };
}

declare module 'three/src/renderers/webgl/WebGLBufferRenderer' {
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLInfo } from 'three/src/renderers/webgl/WebGLInfo';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    
    export class WebGLBufferRenderer {
        constructor(
            gl: WebGLRenderingContext,
            extensions: WebGLExtensions,
            info: WebGLInfo,
            capabilities: WebGLCapabilities,
        );
    
        setMode(value: any): void;
        render(start: any, count: number): void;
        renderInstances(start: any, count: number, primcount: number): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLCapabilities' {
    export interface WebGLCapabilitiesParameters {
        precision?: string | undefined;
        logarithmicDepthBuffer?: boolean | undefined;
    }
    
    export class WebGLCapabilities {
        constructor(gl: WebGLRenderingContext, extensions: any, parameters: WebGLCapabilitiesParameters);
    
        readonly isWebGL2: boolean;
        precision: string;
        logarithmicDepthBuffer: boolean;
        maxTextures: number;
        maxVertexTextures: number;
        maxTextureSize: number;
        maxCubemapSize: number;
        maxAttributes: number;
        maxVertexUniforms: number;
        maxVaryings: number;
        maxFragmentUniforms: number;
        vertexTextures: boolean;
        floatFragmentTextures: boolean;
        floatVertexTextures: boolean;
    
        getMaxAnisotropy(): number;
        getMaxPrecision(precision: string): string;
    }
}

declare module 'three/src/renderers/webgl/WebGLClipping' {
    import { Camera } from 'three/src/cameras/Camera';
    import { Material } from 'three/src/materials/Material';
    import { WebGLProperties } from 'three/src/renderers/webgl/WebGLProperties';
    
    export class WebGLClipping {
            constructor(properties: WebGLProperties);
    
            uniform: { value: any; needsUpdate: boolean };
    
            /**
                * @default 0
                */
            numPlanes: number;
    
            /**
                * @default 0
                */
            numIntersection: number;
    
            init(planes: any[], enableLocalClipping: boolean, camera: Camera): boolean;
            beginShadows(): void;
            endShadows(): void;
            setState(material: Material, camera: Camera, useCache: boolean): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLCubeUVMaps' {
    import { WebGLRenderer, Texture } from 'three/src/Three';
    
    export class WebGLCubeUVMaps {
        constructor(renderer: WebGLRenderer);
    
        get<T>(texture: T): T extends Texture ? Texture : T;
        dispose(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLExtensions' {
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    
    export class WebGLExtensions {
        constructor(gl: WebGLRenderingContext);
    
        has(name: string): boolean;
        init(capabilities: WebGLCapabilities): void;
        get(name: string): any;
    }
}

declare module 'three/src/renderers/webgl/WebGLGeometries' {
    import { WebGLAttributes } from 'three/src/renderers/webgl/WebGLAttributes';
    import { WebGLInfo } from 'three/src/renderers/webgl/WebGLInfo';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { Object3D } from 'three/src/core/Object3D';
    
    export class WebGLGeometries {
        constructor(gl: WebGLRenderingContext, attributes: WebGLAttributes, info: WebGLInfo);
    
        get(object: Object3D, geometry: BufferGeometry): BufferGeometry;
        update(geometry: BufferGeometry): void;
        getWireframeAttribute(geometry: BufferGeometry): BufferAttribute;
    }
}

declare module 'three/src/renderers/webgl/WebGLIndexedBufferRenderer' {
    export class WebGLIndexedBufferRenderer {
        constructor(gl: WebGLRenderingContext, extensions: any, info: any, capabilities: any);
    
        setMode(value: any): void;
        setIndex(index: any): void;
        render(start: any, count: number): void;
        renderInstances(start: any, count: number, primcount: number): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLInfo' {
    import { WebGLProgram } from 'three/src/renderers/webgl/WebGLProgram';
    
    /**
        * An object with a series of statistical information about the graphics board memory and the rendering process.
        */
    export class WebGLInfo {
            constructor(gl: WebGLRenderingContext);
    
            /**
                * @default true
                */
            autoReset: boolean;
    
            /**
                * @default { geometries: 0, textures: 0 }
                */
            memory: {
                    geometries: number;
                    textures: number;
            };
    
            /**
                * @default null
                */
            programs: WebGLProgram[] | null;
    
            /**
                * @default { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
                */
            render: {
                    calls: number;
                    frame: number;
                    lines: number;
                    points: number;
                    triangles: number;
            };
            update(count: number, mode: number, instanceCount: number): void;
            reset(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLLights' {
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    
    export class WebGLLights {
        constructor(extensions: WebGLExtensions, capabilities: WebGLCapabilities);
    
        state: {
            version: number;
    
            hash: {
                directionalLength: number;
                pointLength: number;
                spotLength: number;
                rectAreaLength: number;
                hemiLength: number;
    
                numDirectionalShadows: number;
                numPointShadows: number;
                numSpotShadows: number;
            };
    
            ambient: number[];
            probe: any[];
            directional: any[];
            directionalShadow: any[];
            directionalShadowMap: any[];
            directionalShadowMatrix: any[];
            spot: any[];
            spotShadow: any[];
            spotShadowMap: any[];
            spotShadowMatrix: any[];
            rectArea: any[];
            point: any[];
            pointShadow: any[];
            pointShadowMap: any[];
            pointShadowMatrix: any[];
            hemi: any[];
        };
    
        get(light: any): any;
        setup(lights: any): void;
        setupView(lights: any, camera: any): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLObjects' {
    export class WebGLObjects {
        constructor(gl: WebGLRenderingContext, geometries: any, attributes: any, info: any);
    
        update(object: any): any;
        dispose(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLProgram' {
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { WebGLShader } from 'three/src/renderers/webgl/WebGLShader';
    import { WebGLUniforms } from 'three/src/renderers/webgl/WebGLUniforms';
    export class WebGLProgram {
            constructor(renderer: WebGLRenderer, cacheKey: string, parameters: object);
            name: string;
            id: number;
            cacheKey: string;
            /**
                * @default 1
                */
            usedTimes: number;
            program: any;
            vertexShader: WebGLShader;
            fragmentShader: WebGLShader;
            /**
                * @deprecated Use getUniforms() instead.
                */
            uniforms: any;
            /**
                * @deprecated Use getAttributes() instead.
                */
            attributes: any;
            getUniforms(): WebGLUniforms;
            getAttributes(): any;
            destroy(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLPrograms' {
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { WebGLProgram } from 'three/src/renderers/webgl/WebGLProgram';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { WebGLCubeMaps } from 'three/src/renderers/webgl/WebGLCubeMaps';
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLClipping } from 'three/src/renderers/webgl/WebGLClipping';
    import { WebGLBindingStates } from 'three/src/renderers/webgl/WebGLBindingStates';
    import { Material } from 'three/src/materials/Material';
    import { Scene } from 'three/src/scenes/Scene';
    
    export class WebGLPrograms {
        constructor(
            renderer: WebGLRenderer,
            cubemaps: WebGLCubeMaps,
            extensions: WebGLExtensions,
            capabilities: WebGLCapabilities,
            bindingStates: WebGLBindingStates,
            clipping: WebGLClipping,
        );
    
        programs: WebGLProgram[];
    
        getParameters(material: Material, lights: any, shadows: object[], scene: Scene, object: any): any;
        getProgramCacheKey(parameters: any): string;
        getUniforms(material: Material): object;
        acquireProgram(parameters: any, cacheKey: string): WebGLProgram;
        releaseProgram(program: WebGLProgram): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLProperties' {
    export class WebGLProperties {
        constructor();
    
        get(object: any): any;
        remove(object: any): void;
        update(object: any, key: any, value: any): any;
        dispose(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLRenderLists' {
    import { Object3D } from 'three/src/core/Object3D';
    import { Material } from 'three/src/materials/Material';
    import { WebGLProgram } from 'three/src/renderers/webgl/WebGLProgram';
    import { Group } from 'three/src/objects/Group';
    import { Scene } from 'three/src/scenes/Scene';
    import { Camera } from 'three/src/cameras/Camera';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { WebGLProperties } from 'three/src/renderers/webgl/WebGLProperties';
    
    export interface RenderItem {
            id: number;
            object: Object3D;
            geometry: BufferGeometry | null;
            material: Material;
            program: WebGLProgram;
            groupOrder: number;
            renderOrder: number;
            z: number;
            group: Group | null;
    }
    
    export class WebGLRenderList {
            constructor(properties: WebGLProperties);
    
            /**
                * @default []
                */
            opaque: RenderItem[];
    
            /**
                * @default []
                */
            transparent: RenderItem[];
    
            /**
                * @default []
                */
            transmissive: RenderItem[];
    
            init(): void;
            push(
                    object: Object3D,
                    geometry: BufferGeometry | null,
                    material: Material,
                    groupOrder: number,
                    z: number,
                    group: Group | null,
            ): void;
            unshift(
                    object: Object3D,
                    geometry: BufferGeometry | null,
                    material: Material,
                    groupOrder: number,
                    z: number,
                    group: Group | null,
            ): void;
            sort(opaqueSort: (a: any, b: any) => number, transparentSort: (a: any, b: any) => number): void;
            finish(): void;
    }
    
    export class WebGLRenderLists {
            constructor(properties: WebGLProperties);
    
            dispose(): void;
            get(scene: Scene, renderCallDepth: number): WebGLRenderList;
    }
}

declare module 'three/src/renderers/webgl/WebGLShader' {
    export function WebGLShader(gl: WebGLRenderingContext, type: string, string: string): WebGLShader;
}

declare module 'three/src/renderers/webgl/WebGLShadowMap' {
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { Scene } from 'three/src/scenes/Scene';
    import { Camera } from 'three/src/cameras/Camera';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { ShadowMapType } from 'three/src/constants';
    import { WebGLObjects } from 'three/src/renderers/webgl/WebGLObjects';
    import { Light } from 'three/src/lights/Light';
    
    export class WebGLShadowMap {
            constructor(_renderer: WebGLRenderer, _objects: WebGLObjects, _capabilities: WebGLCapabilities);
    
            /**
                * @default false
                */
            enabled: boolean;
    
            /**
                * @default true
                */
            autoUpdate: boolean;
    
            /**
                * @default false
                */
            needsUpdate: boolean;
    
            /**
                * @default THREE.PCFShadowMap
                */
            type: ShadowMapType;
    
            render(shadowsArray: Light[], scene: Scene, camera: Camera): void;
    
            /**
                * @deprecated Use {@link Material#shadowSide} instead.
                */
            cullFace: any;
    }
}

declare module 'three/src/renderers/webgl/WebGLState' {
    import {
        CullFace,
        Blending,
        BlendingEquation,
        BlendingSrcFactor,
        BlendingDstFactor,
        DepthModes,
    } from '../../constants';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { Material } from 'three/src/materials/Material';
    import { Vector4 } from 'three/src/math/Vector4';
    
    export class WebGLColorBuffer {
        constructor();
    
        setMask(colorMask: boolean): void;
        setLocked(lock: boolean): void;
        setClear(r: number, g: number, b: number, a: number, premultipliedAlpha: boolean): void;
        reset(): void;
    }
    
    export class WebGLDepthBuffer {
        constructor();
    
        setTest(depthTest: boolean): void;
        setMask(depthMask: boolean): void;
        setFunc(depthFunc: DepthModes): void;
        setLocked(lock: boolean): void;
        setClear(depth: number): void;
        reset(): void;
    }
    
    export class WebGLStencilBuffer {
        constructor();
    
        setTest(stencilTest: boolean): void;
        setMask(stencilMask: number): void;
        setFunc(stencilFunc: number, stencilRef: number, stencilMask: number): void;
        setOp(stencilFail: number, stencilZFail: number, stencilZPass: number): void;
        setLocked(lock: boolean): void;
        setClear(stencil: number): void;
        reset(): void;
    }
    
    export class WebGLState {
        constructor(gl: WebGLRenderingContext, extensions: WebGLExtensions, capabilities: WebGLCapabilities);
    
        buffers: {
            color: WebGLColorBuffer;
            depth: WebGLDepthBuffer;
            stencil: WebGLStencilBuffer;
        };
    
        initAttributes(): void;
        enableAttribute(attribute: number): void;
        enableAttributeAndDivisor(attribute: number, meshPerAttribute: number): void;
        disableUnusedAttributes(): void;
        vertexAttribPointer(
            index: number,
            size: number,
            type: number,
            normalized: boolean,
            stride: number,
            offset: number,
        ): void;
        enable(id: number): void;
        disable(id: number): void;
        bindFramebuffer(target: number, framebuffer: WebGLFramebuffer | null): void;
        bindXRFramebuffer(framebuffer: WebGLFramebuffer | null): void;
        useProgram(program: any): boolean;
        setBlending(
            blending: Blending,
            blendEquation?: BlendingEquation,
            blendSrc?: BlendingSrcFactor,
            blendDst?: BlendingDstFactor,
            blendEquationAlpha?: BlendingEquation,
            blendSrcAlpha?: BlendingSrcFactor,
            blendDstAlpha?: BlendingDstFactor,
            premultiplyAlpha?: boolean,
        ): void;
        setMaterial(material: Material, frontFaceCW: boolean): void;
        setFlipSided(flipSided: boolean): void;
        setCullFace(cullFace: CullFace): void;
        setLineWidth(width: number): void;
        setPolygonOffset(polygonoffset: boolean, factor?: number, units?: number): void;
        setScissorTest(scissorTest: boolean): void;
        activeTexture(webglSlot: number): void;
        bindTexture(webglType: number, webglTexture: any): void;
        unbindTexture(): void;
        // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
        compressedTexImage2D(
            target: number,
            level: number,
            internalformat: number,
            width: number,
            height: number,
            border: number,
            data: ArrayBufferView,
        ): void;
        // Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
        texImage2D(
            target: number,
            level: number,
            internalformat: number,
            width: number,
            height: number,
            border: number,
            format: number,
            type: number,
            pixels: ArrayBufferView | null,
        ): void;
        texImage2D(target: number, level: number, internalformat: number, format: number, type: number, source: any): void;
        texImage3D(
            target: number,
            level: number,
            internalformat: number,
            width: number,
            height: number,
            depth: number,
            border: number,
            format: number,
            type: number,
            pixels: any,
        ): void;
        scissor(scissor: Vector4): void;
        viewport(viewport: Vector4): void;
        reset(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLTextures' {
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLState } from 'three/src/renderers/webgl/WebGLState';
    import { WebGLProperties } from 'three/src/renderers/webgl/WebGLProperties';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { WebGLUtils } from 'three/src/renderers/webgl/WebGLUtils';
    import { WebGLInfo } from 'three/src/renderers/webgl/WebGLInfo';
    
    export class WebGLTextures {
        constructor(
            gl: WebGLRenderingContext,
            extensions: WebGLExtensions,
            state: WebGLState,
            properties: WebGLProperties,
            capabilities: WebGLCapabilities,
            utils: WebGLUtils,
            info: WebGLInfo,
        );
    
        allocateTextureUnit(): void;
        resetTextureUnits(): void;
        setTexture2D(texture: any, slot: number): void;
        setTexture2DArray(texture: any, slot: number): void;
        setTexture3D(texture: any, slot: number): void;
        setTextureCube(texture: any, slot: number): void;
        setupRenderTarget(renderTarget: any): void;
        updateRenderTargetMipmap(renderTarget: any): void;
        updateMultisampleRenderTarget(renderTarget: any): void;
        safeSetTexture2D(texture: any, slot: number): void;
        safeSetTextureCube(texture: any, slot: number): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLUniforms' {
    import { WebGLProgram } from 'three/src/renderers/webgl/WebGLProgram';
    import { WebGLTextures } from 'three/src/renderers/webgl/WebGLTextures';
    
    export class WebGLUniforms {
        constructor(gl: WebGLRenderingContext, program: WebGLProgram);
    
        setValue(gl: WebGLRenderingContext, name: string, value: any, textures: WebGLTextures): void;
        setOptional(gl: WebGLRenderingContext, object: any, name: string): void;
    
        static upload(gl: WebGLRenderingContext, seq: any, values: any[], textures: WebGLTextures): void;
        static seqWithValue(seq: any, values: any[]): any[];
    }
}

declare module 'three/src/renderers/webxr/WebXR' {
    export type XRSessionMode = 'inline' | 'immersive-vr' | 'immersive-ar';
    export type XRReferenceSpaceType = 'viewer' | 'local' | 'local-floor' | 'bounded-floor' | 'unbounded';
    export type XREnvironmentBlendMode = 'opaque' | 'additive' | 'alpha-blend';
    export type XRVisibilityState = 'visible' | 'visible-blurred' | 'hidden';
    export type XRHandedness = 'none' | 'left' | 'right';
    export type XRTargetRayMode = 'gaze' | 'tracked-pointer' | 'screen';
    export type XREye = 'none' | 'left' | 'right';
    export type XREventType = 'end' | 'select' | 'selectstart' | 'selectend' | 'squeeze' | 'squeezestart' | 'squeezeend' | 'inputsourceschange';
    export type XRAnimationLoopCallback = (time: number, frame?: XRFrame) => void;
    export type XRFrameRequestCallback = (time: number, frame: XRFrame) => void;
    export interface XR extends EventTarget {
            requestSession(mode: XRSessionMode, options?: XRSessionInit): Promise<XRSession>;
            isSessionSupported(mode: XRSessionMode): Promise<boolean>;
    }
    export interface Window {
            XRSession?: Constructor<XRSession> | undefined;
            XR?: Constructor<XR> | undefined;
    }
    export interface Navigator {
            xr?: XR | undefined;
    }
    export interface XRReferenceSpace extends EventTarget {
            getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
    }
    export interface XRHitTestOptionsInit {
            space: EventTarget;
            offsetRay?: XRRay | undefined;
    }
    export interface XRTransientInputHitTestOptionsInit {
            profile: string;
            offsetRay?: XRRay | undefined;
    }
    export interface XRViewport {
            readonly x: number;
            readonly y: number;
            readonly width: number;
            readonly height: number;
    }
    export interface WebGLRenderingContext {
            makeXRCompatible(): Promise<void>;
    }
    export interface XRRenderState {
            readonly depthNear: number;
            readonly depthFar: number;
            readonly inlineVerticalFieldOfView?: number | undefined;
            readonly baseLayer?: XRWebGLLayer | undefined;
    }
    export interface XRRenderStateInit {
            depthNear?: number | undefined;
            depthFar?: number | undefined;
            inlineVerticalFieldOfView?: number | undefined;
            baseLayer?: XRWebGLLayer | undefined;
    }
    export interface XRGamepad {
            readonly id: string;
            readonly index: number;
            readonly connected: boolean;
            readonly timestamp: DOMHighResTimeStamp;
            readonly mapping: GamepadMappingType;
            readonly axes: Float32Array;
            readonly buttons: GamepadButton[];
    }
    export interface XRInputSource {
            readonly handedness: XRHandedness;
            readonly targetRayMode: XRTargetRayMode;
            readonly targetRaySpace: EventTarget;
            readonly gripSpace?: EventTarget | undefined;
            readonly profiles: string[];
            readonly gamepad: XRGamepad;
            readonly hand?: XRHand | undefined;
    }
    export interface XRSessionInit {
            optionalFeatures?: string[] | undefined;
            requiredFeatures?: string[] | undefined;
    }
    export interface XRSession extends EventTarget {
            requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;
            updateRenderState(renderStateInit: XRRenderStateInit): Promise<void>;
            requestAnimationFrame(callback: XRFrameRequestCallback): number;
            cancelAnimationFrame(id: number): void;
            end(): Promise<void>;
            renderState: XRRenderState;
            inputSources: XRInputSource[];
            environmentBlendMode: XREnvironmentBlendMode;
            visibilityState: XRVisibilityState;
            requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource>;
            requestHitTestSourceForTransientInput(options: XRTransientInputHitTestOptionsInit): Promise<XRTransientInputHitTestSource>;
            requestHitTest(ray: XRRay, referenceSpace: XRReferenceSpace): Promise<XRHitResult[]>;
            updateWorldTrackingState(options: {
                    planeDetectionState?: {
                            enabled: boolean;
                    } | undefined;
            }): void;
    }
    export interface XRReferenceSpace extends EventTarget {
            getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;
            onreset: any;
    }
    export type XRPlaneSet = Set<XRPlane>;
    export type XRAnchorSet = Set<XRAnchor>;
    export interface XRFrame {
            readonly session: XRSession;
            getViewerPose(referenceSpace: XRReferenceSpace): XRViewerPose | undefined;
            getPose(space: EventTarget, baseSpace: EventTarget): XRPose | undefined;
            getHitTestResults(hitTestSource: XRHitTestSource): XRHitTestResult[];
            getHitTestResultsForTransientInput(hitTestSource: XRTransientInputHitTestSource): XRTransientInputHitTestResult[];
            trackedAnchors?: XRAnchorSet | undefined;
            createAnchor(pose: XRRigidTransform, space: EventTarget): Promise<XRAnchor>;
            worldInformation: {
                    detectedPlanes?: XRPlaneSet | undefined;
            };
            getJointPose(joint: XRJointSpace, baseSpace: EventTarget): XRJointPose;
    }
    export interface XRViewerPose {
            readonly transform: XRRigidTransform;
            readonly views: XRView[];
    }
    export interface XRPose {
            readonly emulatedPosition: boolean;
            readonly transform: XRRigidTransform;
    }
    export interface XRWebGLLayerInit {
            antialias?: boolean | undefined;
            depth?: boolean | undefined;
            stencil?: boolean | undefined;
            alpha?: boolean | undefined;
            ignoreDepthValues?: boolean | undefined;
            framebufferScaleFactor?: number | undefined;
    }
    /**
        * @internal
        */
    export class XRWebGLLayer {
            constructor(session: XRSession, gl: WebGLRenderingContext | undefined, options?: XRWebGLLayerInit);
            /**
                * @internal
                */
            framebuffer: WebGLFramebuffer;
            /**
                * @internal
                */
            framebufferWidth: number;
            /**
                * @internal
                */
            framebufferHeight: number;
            /**
                * @internal
                */
            getViewport(view: XRView): XRViewport;
    }
    export interface DOMPointInit {
            w?: number | undefined;
            x?: number | undefined;
            y?: number | undefined;
            z?: number | undefined;
    }
    /**
        * @internal
        */
    export class XRRigidTransform {
            constructor(matrix: Float32Array | DOMPointInit, direction?: DOMPointInit);
            /**
                * @internal
                */
            position: DOMPointReadOnly;
            /**
                * @internal
                */
            orientation: DOMPointReadOnly;
            /**
                * @internal
                */
            matrix: Float32Array;
            /**
                * @internal
                */
            inverse: XRRigidTransform;
    }
    export interface XRView {
            readonly eye: XREye;
            readonly projectionMatrix: Float32Array;
            readonly viewMatrix: Float32Array;
            readonly transform: XRRigidTransform;
    }
    export interface XRRayDirectionInit {
            x?: number | undefined;
            y?: number | undefined;
            z?: number | undefined;
            w?: number | undefined;
    }
    /**
        * @internal
        */
    export class XRRay {
            /**
                * @internal
                */
            readonly origin: DOMPointReadOnly;
            /**
                * @internal
                */
            readonly direction: XRRayDirectionInit;
            /**
                * @internal
                */
            matrix: Float32Array;
            constructor(transformOrOrigin: XRRigidTransform | DOMPointInit, direction?: XRRayDirectionInit);
    }
    export enum XRHitTestTrackableType {
            'point',
            'plane',
            'mesh'
    }
    export interface XRHitResult {
            hitMatrix: Float32Array;
    }
    export interface XRTransientInputHitTestResult {
            readonly inputSource: XRInputSource;
            readonly results: XRHitTestResult[];
    }
    export interface XRHitTestResult {
            getPose(baseSpace: EventTarget): XRPose | undefined | null;
            createAnchor?(pose: XRRigidTransform): Promise<XRAnchor>;
    }
    export interface XRHitTestSource {
            cancel(): void;
    }
    export interface XRTransientInputHitTestSource {
            cancel(): void;
    }
    export interface XRHitTestOptionsInit {
            space: EventTarget;
            entityTypes?: XRHitTestTrackableType[] | undefined;
            offsetRay?: XRRay | undefined;
    }
    export interface XRTransientInputHitTestOptionsInit {
            profile: string;
            entityTypes?: XRHitTestTrackableType[] | undefined;
            offsetRay?: XRRay | undefined;
    }
    export interface XRAnchor {
            anchorSpace: EventTarget;
            delete(): void;
    }
    export interface XRPlane {
            orientation: 'Horizontal' | 'Vertical';
            planeSpace: EventTarget;
            polygon: DOMPointReadOnly[];
            lastChangedTime: number;
    }
    export enum XRHandJoint {
            'wrist',
            'thumb-metacarpal',
            'thumb-phalanx-proximal',
            'thumb-phalanx-distal',
            'thumb-tip',
            'index-finger-metacarpal',
            'index-finger-phalanx-proximal',
            'index-finger-phalanx-intermediate',
            'index-finger-phalanx-distal',
            'index-finger-tip',
            'middle-finger-metacarpal',
            'middle-finger-phalanx-proximal',
            'middle-finger-phalanx-intermediate',
            'middle-finger-phalanx-distal',
            'middle-finger-tip',
            'ring-finger-metacarpal',
            'ring-finger-phalanx-proximal',
            'ring-finger-phalanx-intermediate',
            'ring-finger-phalanx-distal',
            'ring-finger-tip',
            'pinky-finger-metacarpal',
            'pinky-finger-phalanx-proximal',
            'pinky-finger-phalanx-intermediate',
            'pinky-finger-phalanx-distal',
            'pinky-finger-tip'
    }
    export interface XRJointSpace extends EventTarget {
            readonly jointName: XRHandJoint;
    }
    export interface XRJointPose extends XRPose {
            readonly radius: number | undefined;
    }
    export interface XRHand extends Map<XRHandJoint, XRJointSpace> {
            readonly size: number;
    }
    export interface Constructor<T = object> {
            new (...args: any[]): T;
            prototype: T;
    }
    export interface XRInputSourceChangeEvent {
            session: XRSession;
            removed: XRInputSource[];
            added: XRInputSource[];
    }
    export interface XRInputSourceEvent extends Event {
            readonly frame: XRFrame;
            readonly inputSource: XRInputSource;
    }
}

declare module 'three/src/renderers/webxr/WebXRController' {
    import { Group } from 'three/src/objects/Group';
    import { XREventType, XRFrame, XRInputSource, XRReferenceSpace } from 'three/src/renderers/webxr/WebXR';
    export type XRControllerEventType = XREventType | 'disconnected' | 'connected';
    /**
        * @internal
        */
    export class WebXRController {
            constructor();
            /**
                * @internal
                */
            getTargetRaySpace(): Group;
            /**
                * @internal
                */
            getGripSpace(): Group;
            /**
                * @internal
                */
            dispatchEvent(event: {
                    type: XRControllerEventType;
                    data?: XRInputSource | undefined;
            }): this;
            /**
                * @internal
                */
            disconnect(inputSource: XRInputSource): this;
            /**
                * @internal
                */
            update(inputSource: XRInputSource, frame: XRFrame, referenceSpace: XRReferenceSpace): this;
    }
}

declare module 'three/src/renderers/webxr/WebXRManager' {
    import { Group } from 'three/src/objects/Group';
    import { Camera } from 'three/src/cameras/Camera';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { XRFrameRequestCallback, XRReferenceSpace, XRReferenceSpaceType, XRSession } from 'three/src/renderers/webxr/WebXR';
    export class WebXRManager extends EventDispatcher {
            constructor(renderer: any, gl: WebGLRenderingContext);
            /**
                * @default false
                */
            enabled: boolean;
            /**
                * @default false
                */
            isPresenting: boolean;
            getController(index: number): Group;
            getControllerGrip(index: number): Group;
            getHand(index: number): Group;
            setFramebufferScaleFactor(value: number): void;
            setReferenceSpaceType(value: XRReferenceSpaceType): void;
            getReferenceSpace(): XRReferenceSpace | null;
            getSession(): XRSession | null;
            /**
                * @internal
                */
            setSession(value: XRSession): Promise<void>;
            getCamera(camera: Camera): Camera;
            /**
                * @internal
                */
            setAnimationLoop(callback: XRFrameRequestCallback | null): void;
            getFoveation(): number | undefined;
            setFoveation(foveation: number): void;
            /**
                * @internal
                */
            dispose(): void;
    }
}

declare module 'three/src/scenes/FogExp2' {
    import { Color } from 'three/src/math/Color';
    import { FogBase } from 'three/src/scenes/Fog';
    export class FogExp2 implements FogBase {
            constructor(hex: number | string, density?: number);
            /**
                * @default ''
                */
            name: string;
            color: Color;
            /**
                * @default 0.00025
                */
            density: number;
            readonly isFogExp2: true;
            clone(): FogExp2;
            toJSON(): any;
    }
}

declare module 'three/src/scenes/Fog' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Color } from 'three/src/math/Color';
    export interface FogBase {
            name: string;
            color: Color;
            clone(): FogBase;
            toJSON(): any;
    }
    export class Fog implements FogBase {
            constructor(color: ColorRepresentation, near?: number, far?: number);
            /**
                * @default ''
                */
            name: string;
            color: Color;
            /**
                * @default 1
                */
            near: number;
            /**
                * @default 1000
                */
            far: number;
            readonly isFog: true;
            clone(): Fog;
            toJSON(): any;
    }
}

declare module 'three/src/scenes/Scene' {
    import { FogBase } from 'three/src/scenes/Fog';
    import { Material } from 'three/src/materials/Material';
    import { Object3D } from 'three/src/core/Object3D';
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { Camera } from 'three/src/cameras/Camera';
    export class Scene extends Object3D {
            constructor();
            /**
                * @internal
                */
            type: 'Scene';
            /**
                * @default null
                */
            fog: FogBase | null;
            /**
                * @default null
                */
            overrideMaterial: Material | null;
            /**
                * @default true
                */
            autoUpdate: boolean;
            /**
                * @default null
                */
            background: null | Color | Texture;
            /**
                * @default null
                */
            environment: null | Texture;
            readonly isScene: true;
            /**
                * @internal
                */
            onBeforeRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera, renderTarget: any) => void;
            /**
                * @internal
                */
            onAfterRender: (renderer: WebGLRenderer, scene: Scene, camera: Camera) => void;
            toJSON(meta?: any): any;
    }
}

declare module 'three/src/textures/VideoTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, PixelFormat, TextureDataType } from 'three/src/constants';
    export class VideoTexture extends Texture {
        constructor(video: HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number);
        readonly isVideoTexture: true;
        /**
          * @default false
          */
        generateMipmaps: boolean;
    }
}

declare module 'three/src/textures/DataTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, PixelFormat, TextureDataType, TextureEncoding } from 'three/src/constants';
    export class DataTexture extends Texture {
            constructor(data?: BufferSource | null, width?: number, height?: number, format?: PixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number, encoding?: TextureEncoding);
            get image(): ImageData;
            set image(value: ImageData);
            /**
                * @default false
                */
            flipY: boolean;
            /**
                * @default false
                */
            generateMipmaps: boolean;
            /**
                * @default 1
                */
            unpackAlignment: number;
            /**
                * @default THREE.DepthFormat
                * @internal
                */
            format: PixelFormat;
            readonly isDataTexture: true;
    }
}

declare module 'three/src/textures/DataTexture2DArray' {
    import { DataArrayTexture } from 'three/src/textures/DataArrayTexture';
    /**
      * @deprecated THREE.DataTexture2DArray has been renamed to DataArrayTexture.
      */
    export class DataTexture2DArray extends DataArrayTexture {
    }
}

declare module 'three/src/textures/DataTexture3D' {
    import { Data3DTexture } from 'three/src/textures/Data3DTexture';
    /**
      * @deprecated THREE.DataTexture3D has been renamed to Data3DTexture.
      */
    export class DataTexture3D extends Data3DTexture {
    }
}

declare module 'three/src/textures/CompressedTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, CompressedPixelFormat, TextureDataType, TextureEncoding, } from 'three/src/constants';
    export class CompressedTexture extends Texture {
            constructor(mipmaps: ImageData[], width: number, height: number, format?: CompressedPixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number, encoding?: TextureEncoding);
            get image(): {
                    width: number;
                    height: number;
            };
            set image(value: {
                    width: number;
                    height: number;
            });
            /**
                * @internal
                */
            mipmaps: ImageData[];
            /**
                * @default false
                */
            flipY: boolean;
            /**
                * @default false
                */
            generateMipmaps: boolean;
            readonly isCompressedTexture: true;
    }
}

declare module 'three/src/textures/CubeTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, PixelFormat, TextureDataType, TextureEncoding } from 'three/src/constants';
    export class CubeTexture extends Texture {
            constructor(images?: any[], mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, encoding?: TextureEncoding);
            /**
                * @internal
                */
            images: any;
            /**
                * @default false
                */
            flipY: boolean;
            readonly isCubeTexture: true;
    }
}

declare module 'three/src/textures/Data3DTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { TextureFilter } from 'three/src/constants';
    export class Data3DTexture extends Texture {
            constructor(data: BufferSource, width: number, height: number, depth: number);
            /**
                * @default THREE.NearestFilter
                * @internal
                */
            magFilter: TextureFilter;
            /**
                * @default THREE.NearestFilter
                * @internal
                */
            minFilter: TextureFilter;
            /**
                * @default THREE.ClampToEdgeWrapping
                */
            wrapR: boolean;
            /**
                * @default false
                * @internal
                */
            flipY: boolean;
            /**
                * @default false
                * @internal
                */
            generateMipmaps: boolean;
            /**
                * @internal
                */
            readonly isData3DTexture: true;
    }
}

declare module 'three/src/textures/DataArrayTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { TextureFilter } from 'three/src/constants';
    export class DataArrayTexture extends Texture {
            constructor(data?: BufferSource, width?: number, height?: number, depth?: number);
            /**
                * @default THREE.NearestFilter
                * @internal
                */
            magFilter: TextureFilter;
            /**
                * @default THREE.NearestFilter
                * @internal
                */
            minFilter: TextureFilter;
            /**
                * @default THREE.ClampToEdgeWrapping
                * @internal
                */
            wrapR: boolean;
            /**
                * @default false
                * @internal
                */
            flipY: boolean;
            /**
                * @default false
                * @internal
                */
            generateMipmaps: boolean;
            /**
                * @internal
                */
            readonly isDataArrayTexture: true;
    }
}

declare module 'three/src/textures/CanvasTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, PixelFormat, TextureDataType } from 'three/src/constants';
    export class CanvasTexture extends Texture {
        constructor(canvas: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number);
        readonly isCanvasTexture: true;
    }
}

declare module 'three/src/textures/DepthTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { Mapping, Wrapping, TextureFilter, TextureDataType } from 'three/src/constants';
    export class DepthTexture extends Texture {
            constructor(width: number, height: number, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number);
            get image(): {
                    width: number;
                    height: number;
            };
            set image(value: {
                    width: number;
                    height: number;
            });
            /**
                * @default false
                */
            flipY: boolean;
            /**
                * @default false
                * @internal
                */
            generateMipmaps: boolean;
            readonly isDepthTexture: true;
    }
}

declare module 'three/src/textures/FramebufferTexture' {
    import { Texture } from 'three/src/textures/Texture';
    import { PixelFormat } from 'three/src/constants';
    export class FramebufferTexture extends Texture {
        readonly isFramebufferTexture: true;
        constructor(width: number, height: number, format: PixelFormat);
    }
}

declare module 'three/src/textures/Source' {
    export class Source {
        constructor(data: any);
        data: any;
        set needsUpdate(value: boolean);
        uuid: string;
        version: number;
        toJSON(meta: any): any;
        /**
          * @internal
          */
        readonly isTexture: true;
    }
}

declare module 'three/src/textures/Texture' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Matrix3 } from 'three/src/math/Matrix3';
    import { Source } from 'three/src/textures/Source';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { Mapping, Wrapping, TextureFilter, PixelFormat, PixelFormatGPU, TextureDataType, TextureEncoding, } from 'three/src/constants';
    export class Texture extends EventDispatcher {
            constructor(image?: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, encoding?: TextureEncoding);
            id: number;
            uuid: string;
            /**
                * @default ''
                */
            name: string;
            /**
                * @internal
                */
            sourceFile: string;
            source: Source;
            get image(): any;
            set image(data: any);
            /**
                * @default []
                */
            mipmaps: any[];
            /**
                * @default THREE.Texture.DEFAULT_MAPPING
                */
            mapping: Mapping;
            /**
                * @default THREE.ClampToEdgeWrapping
                */
            wrapS: Wrapping;
            /**
                * @default THREE.ClampToEdgeWrapping
                */
            wrapT: Wrapping;
            /**
                * @default THREE.LinearFilter
                */
            magFilter: TextureFilter;
            /**
                * @default THREE.LinearMipmapLinearFilter
                */
            minFilter: TextureFilter;
            /**
                * @default 1
                */
            anisotropy: number;
            /**
                * @default THREE.RGBAFormat
                */
            format: PixelFormat;
            internalFormat: PixelFormatGPU | null;
            /**
                * @default THREE.UnsignedByteType
                */
            type: TextureDataType;
            /**
                * @default new THREE.Matrix3()
                */
            matrix: Matrix3;
            /**
                * @default true
                */
            matrixAutoUpdate: boolean;
            /**
                * @default new THREE.Vector2( 0, 0 )
                */
            offset: Vector2;
            /**
                * @default new THREE.Vector2( 1, 1 )
                */
            repeat: Vector2;
            /**
                * @default new THREE.Vector2( 0, 0 )
                */
            center: Vector2;
            /**
                * @default 0
                */
            rotation: number;
            /**
                * @default true
                */
            generateMipmaps: boolean;
            /**
                * @default false
                */
            premultiplyAlpha: boolean;
            /**
                * @default true
                */
            flipY: boolean;
            /**
                * @default 4
                */
            unpackAlignment: number;
            /**
                * @default THREE.LinearEncoding
                */
            encoding: TextureEncoding;
            /**
                * @default false
                * @internal
                */
            isRenderTargetTexture: boolean;
            /**
                * @default false
                * @internal
                */
            needsPMREMUpdate: boolean;
            /**
                * @default {}
                */
            userData: any;
            /**
                * @default 0
                */
            version: number;
            set needsUpdate(value: boolean);
            readonly isTexture: true;
            onUpdate: () => void;
            /**
                * @internal
                */
            static DEFAULT_IMAGE: any;
            /**
                * @internal
                */
            static DEFAULT_MAPPING: any;
            clone(): this;
            /**
                * @internal
                */
            copy(source: Texture): this;
            toJSON(meta: any): any;
            dispose(): void;
            transformUv(uv: Vector2): Vector2;
            updateMatrix(): void;
    }
}

declare module 'three/src/materials/Material' {
    import { Plane } from 'three/src/math/Plane';
    import { EventDispatcher } from 'three/src/core/EventDispatcher';
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    import { Shader } from 'three/src/renderers/shaders/ShaderLib';
    import { BlendingDstFactor, BlendingEquation, Blending, BlendingSrcFactor, DepthModes, Side, StencilFunc, StencilOp, PixelFormat, } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    export interface MaterialParameters {
            alphaTest?: number | undefined;
            alphaToCoverage?: boolean | undefined;
            blendDst?: BlendingDstFactor | undefined;
            blendDstAlpha?: number | undefined;
            blendEquation?: BlendingEquation | undefined;
            blendEquationAlpha?: number | undefined;
            blending?: Blending | undefined;
            blendSrc?: BlendingSrcFactor | BlendingDstFactor | undefined;
            blendSrcAlpha?: number | undefined;
            clipIntersection?: boolean | undefined;
            clippingPlanes?: Plane[] | undefined;
            clipShadows?: boolean | undefined;
            colorWrite?: boolean | undefined;
            defines?: any;
            depthFunc?: DepthModes | undefined;
            depthTest?: boolean | undefined;
            depthWrite?: boolean | undefined;
            fog?: boolean | undefined;
            name?: string | undefined;
            opacity?: number | undefined;
            polygonOffset?: boolean | undefined;
            polygonOffsetFactor?: number | undefined;
            polygonOffsetUnits?: number | undefined;
            precision?: 'highp' | 'mediump' | 'lowp' | null | undefined;
            premultipliedAlpha?: boolean | undefined;
            dithering?: boolean | undefined;
            side?: Side | undefined;
            shadowSide?: Side | undefined;
            toneMapped?: boolean | undefined;
            transparent?: boolean | undefined;
            vertexColors?: boolean | undefined;
            visible?: boolean | undefined;
            format?: PixelFormat | undefined;
            stencilWrite?: boolean | undefined;
            stencilFunc?: StencilFunc | undefined;
            stencilRef?: number | undefined;
            stencilWriteMask?: number | undefined;
            stencilFuncMask?: number | undefined;
            stencilFail?: StencilOp | undefined;
            stencilZFail?: StencilOp | undefined;
            stencilZPass?: StencilOp | undefined;
            userData?: any;
    }
    export class Material extends EventDispatcher {
            constructor();
            /**
                * @default 0
                */
            alphaTest: number;
            /**
                * @default false
                */
            alphaToCoverage: boolean;
            /**
                * @default THREE.OneMinusSrcAlphaFactor
                */
            blendDst: BlendingDstFactor;
            /**
                * @default null
                */
            blendDstAlpha: number | null;
            /**
                * @default THREE.AddEquation
                */
            blendEquation: BlendingEquation;
            /**
                * @default null
                */
            blendEquationAlpha: number | null;
            /**
                * @default THREE.NormalBlending
                */
            blending: Blending;
            /**
                * @default THREE.SrcAlphaFactor
                */
            blendSrc: BlendingSrcFactor | BlendingDstFactor;
            /**
                * @default null
                */
            blendSrcAlpha: number | null;
            /**
                * @default false
                */
            clipIntersection: boolean;
            /**
                * @default null
                */
            clippingPlanes: any;
            /**
                * @default false
                */
            clipShadows: boolean;
            /**
                * @default true
                */
            colorWrite: boolean;
            /**
                * @default undefined
                */
            defines: undefined | {
                    [key: string]: any;
            };
            /**
                * @default THREE.LessEqualDepth
                */
            depthFunc: DepthModes;
            /**
                * @default true
                */
            depthTest: boolean;
            /**
                * @default true
                */
            depthWrite: boolean;
            /**
                * @default fog
                */
            fog: boolean;
            id: number;
            /**
                * @default false
                */
            stencilWrite: boolean;
            /**
                * @default THREE.AlwaysStencilFunc
                */
            stencilFunc: StencilFunc;
            /**
                * @default 0
                */
            stencilRef: number;
            /**
                * @default 0xff
                */
            stencilWriteMask: number;
            /**
                * @default 0xff
                */
            stencilFuncMask: number;
            /**
                * @default THREE.KeepStencilOp
                */
            stencilFail: StencilOp;
            /**
                * @default THREE.KeepStencilOp
                */
            stencilZFail: StencilOp;
            /**
                * @default THREE.KeepStencilOp
                */
            stencilZPass: StencilOp;
            readonly isMaterial: true;
            /**
                * @default ''
                */
            name: string;
            /**
                * @default false
                */
            needsUpdate: boolean;
            /**
                * @default 1
                */
            opacity: number;
            /**
                * @default false
                */
            polygonOffset: boolean;
            /**
                * @default 0
                */
            polygonOffsetFactor: number;
            /**
                * @default 0
                */
            polygonOffsetUnits: number;
            /**
                * @default null
                */
            precision: 'highp' | 'mediump' | 'lowp' | null;
            /**
                * @default false
                */
            premultipliedAlpha: boolean;
            /**
                * @default false
                */
            dithering: boolean;
            /**
                * @default THREE.FrontSide
                */
            side: Side;
            /**
                * @default null
                */
            shadowSide: Side | null;
            /**
                * @default true
                */
            toneMapped: boolean;
            /**
                * @default false
                */
            transparent: boolean;
            /**
                * @default 'Material'
                */
            type: string;
            uuid: string;
            /**
                * @default false
                */
            vertexColors: boolean;
            /**
                * @default true
                */
            visible: boolean;
            /**
                * @default {}
                */
            userData: any;
            /**
                * @default 0
                */
            version: number;
            clone(): this;
            copy(material: Material): this;
            dispose(): void;
            onBeforeCompile(shader: Shader, renderer: WebGLRenderer): void;
            customProgramCacheKey(): string;
            setValues(values: MaterialParameters): void;
            toJSON(meta?: any): any;
    }
}

declare module 'three/src/extras/curves/ArcCurve' {
    import { EllipseCurve } from 'three/src/extras/curves/EllipseCurve';
    export class ArcCurve extends EllipseCurve {
        constructor(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean);
        /**
          * @default 'ArcCurve'
          * @internal
          */
        type: string;
    }
}

declare module 'three/src/extras/curves/CatmullRomCurve3' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Curve } from 'three/src/extras/core/Curve';
    /**
        * @internal
        */
    export namespace CurveUtils {
            /**
                * @internal
                */
            function tangentQuadraticBezier(t: number, p0: number, p1: number, p2: number): number;
            /**
                * @internal
                */
            function tangentCubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number;
            /**
                * @internal
                */
            function tangentSpline(t: number, p0: number, p1: number, p2: number, p3: number): number;
            /**
                * @internal
                */
            function interpolate(p0: number, p1: number, p2: number, p3: number, t: number): number;
    }
    export class CatmullRomCurve3 extends Curve<Vector3> {
            constructor(points?: Vector3[], closed?: boolean, curveType?: string, tension?: number);
            /**
                * @default 'CatmullRomCurve3'
                * @internal
                */
            type: string;
            /**
                * @default []
                */
            points: Vector3[];
    }
}

declare module 'three/src/extras/curves/CubicBezierCurve' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Curve } from 'three/src/extras/core/Curve';
    export class CubicBezierCurve extends Curve<Vector2> {
            constructor(v0: Vector2, v1: Vector2, v2: Vector2, v3: Vector2);
            /**
                * @default 'CubicBezierCurve'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector2()
                */
            v0: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v1: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v2: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v3: Vector2;
    }
}

declare module 'three/src/extras/curves/CubicBezierCurve3' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Curve } from 'three/src/extras/core/Curve';
    export class CubicBezierCurve3 extends Curve<Vector3> {
            constructor(v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3);
            /**
                * @default 'CubicBezierCurve3'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector3()
                */
            v0: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v1: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v2: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v3: Vector3;
    }
}

declare module 'three/src/extras/curves/EllipseCurve' {
    import { Curve } from 'three/src/extras/core/Curve';
    import { Vector2 } from 'three/src/math/Vector2';
    export class EllipseCurve extends Curve<Vector2> {
            constructor(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean, aRotation: number);
            /**
                * @default 'EllipseCurve'
                * @internal
                */
            type: string;
            /**
                * @default 0
                */
            aX: number;
            /**
                * @default 0
                */
            aY: number;
            /**
                * @default 1
                */
            xRadius: number;
            /**
                * @default 1
                */
            yRadius: number;
            /**
                * @default 0
                */
            aStartAngle: number;
            /**
                * @default 2 * Math.PI
                */
            aEndAngle: number;
            /**
                * @default false
                */
            aClockwise: boolean;
            /**
                * @default 0
                */
            aRotation: number;
    }
}

declare module 'three/src/extras/curves/LineCurve' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Curve } from 'three/src/extras/core/Curve';
    export class LineCurve extends Curve<Vector2> {
            constructor(v1: Vector2, v2: Vector2);
            /**
                * @default 'LineCurve'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector2()
                */
            v1: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v2: Vector2;
    }
}

declare module 'three/src/extras/curves/LineCurve3' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Curve } from 'three/src/extras/core/Curve';
    export class LineCurve3 extends Curve<Vector3> {
            constructor(v1: Vector3, v2: Vector3);
            /**
                * @default 'LineCurve3'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector3()
                */
            v1: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v2: Vector3;
    }
}

declare module 'three/src/extras/curves/QuadraticBezierCurve' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Curve } from 'three/src/extras/core/Curve';
    export class QuadraticBezierCurve extends Curve<Vector2> {
            constructor(v0: Vector2, v1: Vector2, v2: Vector2);
            /**
                * @default 'QuadraticBezierCurve'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector2()
                */
            v0: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v1: Vector2;
            /**
                * @default new THREE.Vector2()
                */
            v2: Vector2;
    }
}

declare module 'three/src/extras/curves/QuadraticBezierCurve3' {
    import { Vector3 } from 'three/src/math/Vector3';
    import { Curve } from 'three/src/extras/core/Curve';
    export class QuadraticBezierCurve3 extends Curve<Vector3> {
            constructor(v0: Vector3, v1: Vector3, v2: Vector3);
            /**
                * @default 'QuadraticBezierCurve3'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Vector3()
                */
            v0: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v1: Vector3;
            /**
                * @default new THREE.Vector3()
                */
            v2: Vector3;
    }
}

declare module 'three/src/extras/curves/SplineCurve' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { Curve } from 'three/src/extras/core/Curve';
    export class SplineCurve extends Curve<Vector2> {
            constructor(points?: Vector2[]);
            /**
                * @default 'SplineCurve'
                * @internal
                */
            type: string;
            /**
                * @default []
                */
            points: Vector2[];
    }
}

declare module 'three/src/geometries/BoxGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class BoxGeometry extends BufferGeometry {
            constructor(width?: number, height?: number, depth?: number, widthSegments?: number, heightSegments?: number, depthSegments?: number);
            /**
                * @default 'BoxGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    width: number;
                    height: number;
                    depth: number;
                    widthSegments: number;
                    heightSegments: number;
                    depthSegments: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): BoxGeometry;
    }
    export { BoxGeometry as BoxBufferGeometry };
}

declare module 'three/src/geometries/CapsuleGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class CapsuleGeometry extends BufferGeometry {
            constructor(radius?: number, length?: number, capSegments?: number, radialSegments?: number);
            /**
                * @default 'CapsuleGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radius: number;
                    length: number;
                    capSegments: number;
                    radialSegments: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): CapsuleGeometry;
    }
    export { CapsuleGeometry as CapsuleBufferGeometry };
}

declare module 'three/src/geometries/CircleGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class CircleGeometry extends BufferGeometry {
            constructor(radius?: number, segments?: number, thetaStart?: number, thetaLength?: number);
            /**
                * @default 'CircleGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radius: number;
                    segments: number;
                    thetaStart: number;
                    thetaLength: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): CircleGeometry;
    }
    export { CircleGeometry as CircleBufferGeometry };
}

declare module 'three/src/geometries/ConeGeometry' {
    import { CylinderGeometry } from 'three/src/geometries/CylinderGeometry';
    export class ConeGeometry extends CylinderGeometry {
            constructor(radius?: number, height?: number, radialSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number);
            /**
                * @default 'ConeGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            static fromJSON(data: any): ConeGeometry;
    }
    export { ConeGeometry as ConeBufferGeometry };
}

declare module 'three/src/geometries/CylinderGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class CylinderGeometry extends BufferGeometry {
            constructor(radiusTop?: number, radiusBottom?: number, height?: number, radialSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number);
            /**
                * @default 'CylinderGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radiusTop: number;
                    radiusBottom: number;
                    height: number;
                    radialSegments: number;
                    heightSegments: number;
                    openEnded: boolean;
                    thetaStart: number;
                    thetaLength: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): CylinderGeometry;
    }
    export { CylinderGeometry as CylinderBufferGeometry };
}

declare module 'three/src/geometries/DodecahedronGeometry' {
    import { PolyhedronGeometry } from 'three/src/geometries/PolyhedronGeometry';
    export class DodecahedronGeometry extends PolyhedronGeometry {
            constructor(radius?: number, detail?: number);
            /**
                * @default 'DodecahedronGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            static fromJSON(data: any): DodecahedronGeometry;
    }
    export { DodecahedronGeometry as DodecahedronBufferGeometry };
}

declare module 'three/src/geometries/EdgesGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class EdgesGeometry<TBufferGeometry extends BufferGeometry = BufferGeometry> extends BufferGeometry {
        constructor(geometry?: TBufferGeometry, thresholdAngle?: number);
        /**
          * @default 'EdgesGeometry'
          * @internal
          */
        type: string;
        parameters: {
            geometry: TBufferGeometry;
            thresholdAngle: number;
        };
    }
}

declare module 'three/src/geometries/ExtrudeGeometry' {
    import { Curve } from 'three/src/extras/core/Curve';
    import { Vector2 } from 'three/src/math/Vector2';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Shape } from 'three/src/extras/core/Shape';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export interface ExtrudeGeometryOptions {
            curveSegments?: number | undefined;
            steps?: number | undefined;
            depth?: number | undefined;
            bevelEnabled?: boolean | undefined;
            bevelThickness?: number | undefined;
            bevelSize?: number | undefined;
            bevelOffset?: number | undefined;
            bevelSegments?: number | undefined;
            extrudePath?: Curve<Vector3> | undefined;
            UVGenerator?: UVGenerator | undefined;
    }
    export interface UVGenerator {
            generateTopUV(geometry: ExtrudeGeometry, vertices: number[], indexA: number, indexB: number, indexC: number): Vector2[];
            generateSideWallUV(geometry: ExtrudeGeometry, vertices: number[], indexA: number, indexB: number, indexC: number, indexD: number): Vector2[];
    }
    export class ExtrudeGeometry extends BufferGeometry {
            constructor(shapes?: Shape | Shape[], options?: ExtrudeGeometryOptions);
            /**
                * @default 'ExtrudeGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            addShapeList(shapes: Shape[], options?: any): void;
            /**
                * @internal
                */
            addShape(shape: Shape, options?: any): void;
            /**
                * @internal
                */
            static fromJSON(data: any): ExtrudeGeometry;
    }
    export { ExtrudeGeometry as ExtrudeBufferGeometry };
}

declare module 'three/src/geometries/IcosahedronGeometry' {
    import { PolyhedronGeometry } from 'three/src/geometries/PolyhedronGeometry';
    export class IcosahedronGeometry extends PolyhedronGeometry {
            constructor(radius?: number, detail?: number);
            /**
                * @default 'IcosahedronGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            static fromJSON(data: any): IcosahedronGeometry;
    }
    export { IcosahedronGeometry as IcosahedronBufferGeometry };
}

declare module 'three/src/geometries/LatheGeometry' {
    import { Vector2 } from 'three/src/math/Vector2';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class LatheGeometry extends BufferGeometry {
            constructor(points?: Vector2[], segments?: number, phiStart?: number, phiLength?: number);
            /**
                * @default 'LatheGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    points: Vector2[];
                    segments: number;
                    phiStart: number;
                    phiLength: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): LatheGeometry;
    }
    export { LatheGeometry as LatheBufferGeometry };
}

declare module 'three/src/geometries/OctahedronGeometry' {
    import { PolyhedronGeometry } from 'three/src/geometries/PolyhedronGeometry';
    export class OctahedronGeometry extends PolyhedronGeometry {
            constructor(radius?: number, detail?: number);
            /**
                * @default 'OctahedronGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            static fromJSON(data: any): OctahedronGeometry;
    }
    export { OctahedronGeometry as OctahedronBufferGeometry };
}

declare module 'three/src/geometries/PlaneGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class PlaneGeometry extends BufferGeometry {
            constructor(width?: number, height?: number, widthSegments?: number, heightSegments?: number);
            /**
                * @default 'PlaneGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    width: number;
                    height: number;
                    widthSegments: number;
                    heightSegments: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): PlaneGeometry;
    }
    export { PlaneGeometry as PlaneBufferGeometry };
}

declare module 'three/src/geometries/PolyhedronGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class PolyhedronGeometry extends BufferGeometry {
            constructor(vertices?: number[], indices?: number[], radius?: number, detail?: number);
            /**
                * @default 'PolyhedronGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    vertices: number[];
                    indices: number[];
                    radius: number;
                    detail: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): PolyhedronGeometry;
    }
    export { PolyhedronGeometry as PolyhedronBufferGeometry };
}

declare module 'three/src/geometries/RingGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class RingGeometry extends BufferGeometry {
            constructor(innerRadius?: number, outerRadius?: number, thetaSegments?: number, phiSegments?: number, thetaStart?: number, thetaLength?: number);
            /**
                * @default 'RingGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    innerRadius: number;
                    outerRadius: number;
                    thetaSegments: number;
                    phiSegments: number;
                    thetaStart: number;
                    thetaLength: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): RingGeometry;
    }
    export { RingGeometry as RingBufferGeometry };
}

declare module 'three/src/geometries/ShapeGeometry' {
    import { Shape } from 'three/src/extras/core/Shape';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class ShapeGeometry extends BufferGeometry {
            /**
                * @default 'ShapShapeGeometryeBufferGeometry'
                * @internal
                */
            type: string;
            constructor(shapes?: Shape | Shape[], curveSegments?: number);
            /**
                * @internal
                */
            static fromJSON(data: any): ShapeGeometry;
    }
    export { ShapeGeometry as ShapeBufferGeometry };
}

declare module 'three/src/geometries/SphereGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class SphereGeometry extends BufferGeometry {
            constructor(radius?: number, widthSegments?: number, heightSegments?: number, phiStart?: number, phiLength?: number, thetaStart?: number, thetaLength?: number);
            /**
                * @default 'SphereGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radius: number;
                    widthSegments: number;
                    heightSegments: number;
                    phiStart: number;
                    phiLength: number;
                    thetaStart: number;
                    thetaLength: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): SphereGeometry;
    }
    export { SphereGeometry as SphereBufferGeometry };
}

declare module 'three/src/geometries/TetrahedronGeometry' {
    import { PolyhedronGeometry } from 'three/src/geometries/PolyhedronGeometry';
    export class TetrahedronGeometry extends PolyhedronGeometry {
            constructor(radius?: number, detail?: number);
            /**
                * @default 'TetrahedronGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            static fromJSON(data: any): TetrahedronGeometry;
    }
    export { TetrahedronGeometry as TetrahedronBufferGeometry };
}

declare module 'three/src/geometries/TorusGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class TorusGeometry extends BufferGeometry {
            constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number);
            /**
                * @default 'TorusGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radius: number;
                    tube: number;
                    radialSegments: number;
                    tubularSegments: number;
                    arc: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): TorusGeometry;
    }
    export { TorusGeometry as TorusBufferGeometry };
}

declare module 'three/src/geometries/TorusKnotGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class TorusKnotGeometry extends BufferGeometry {
            constructor(radius?: number, tube?: number, tubularSegments?: number, radialSegments?: number, p?: number, q?: number);
            /**
                * @default 'TorusKnotGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    radius: number;
                    tube: number;
                    tubularSegments: number;
                    radialSegments: number;
                    p: number;
                    q: number;
            };
            /**
                * @internal
                */
            static fromJSON(data: any): TorusKnotGeometry;
    }
    export { TorusKnotGeometry as TorusKnotBufferGeometry };
}

declare module 'three/src/geometries/TubeGeometry' {
    import { Curve } from 'three/src/extras/core/Curve';
    import { Vector3 } from 'three/src/math/Vector3';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class TubeGeometry extends BufferGeometry {
            constructor(path?: Curve<Vector3>, tubularSegments?: number, radius?: number, radiusSegments?: number, closed?: boolean);
            /**
                * @default 'TubeGeometry'
                * @internal
                */
            type: string;
            parameters: {
                    path: Curve<Vector3>;
                    tubularSegments: number;
                    radius: number;
                    radialSegments: number;
                    closed: boolean;
            };
            tangents: Vector3[];
            normals: Vector3[];
            binormals: Vector3[];
            /**
                * @internal
                */
            static fromJSON(data: any): TubeGeometry;
    }
    export { TubeGeometry as TubeBufferGeometry };
}

declare module 'three/src/geometries/WireframeGeometry' {
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    export class WireframeGeometry<TBufferGeometry extends BufferGeometry = BufferGeometry> extends BufferGeometry {
            constructor(geometry?: TBufferGeometry);
            /**
                * @default 'WireframeGeometry'
                * @internal
                */
            type: string;
            /**
                * @internal
                */
            parameters: {
                    geometry: TBufferGeometry;
            };
    }
}

declare module 'three/src/materials/MeshBasicMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Combine } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshBasicMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            opacity?: number | undefined;
            map?: Texture | null | undefined;
            lightMap?: Texture | null;
            lightMapIntensity?: number | undefined;
            aoMap?: Texture | null | undefined;
            aoMapIntensity?: number | undefined;
            specularMap?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            envMap?: Texture | null | undefined;
            combine?: Combine | undefined;
            reflectivity?: number | undefined;
            refractionRatio?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            wireframeLinecap?: string | undefined;
            wireframeLinejoin?: string | undefined;
    }
    export class MeshBasicMaterial extends Material {
            constructor(parameters?: MeshBasicMaterialParameters);
            /**
                * @default 'MeshBasicMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            lightMap: Texture | null;
            /**
                * @default 1
                */
            lightMapIntensity: number;
            /**
                * @default null
                */
            aoMap: Texture | null;
            /**
                * @default 1
                */
            aoMapIntensity: number;
            /**
                * @default null
                */
            specularMap: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default null
                */
            envMap: Texture | null;
            /**
                * @default THREE.MultiplyOperation
                */
            combine: Combine;
            /**
                * @default 1
                */
            reflectivity: number;
            /**
                * @default 0.98
                */
            refractionRatio: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default 'round'
                */
            wireframeLinecap: string;
            /**
                * @default 'round'
                */
            wireframeLinejoin: string;
            /**
                * @internal
                */
            setValues(parameters: MeshBasicMaterialParameters): void;
    }
}

declare module 'three/src/materials/ShadowMaterial' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Color } from 'three/src/math/Color';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    export interface ShadowMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
    }
    export class ShadowMaterial extends Material {
            constructor(parameters?: ShadowMaterialParameters);
            /**
                * @default 'ShadowMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0x000000 )
                */
            color: Color;
            /**
                * @default true
                */
            transparent: boolean;
    }
}

declare module 'three/src/materials/SpriteMaterial' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    export interface SpriteMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            map?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            rotation?: number | undefined;
            sizeAttenuation?: boolean | undefined;
    }
    export class SpriteMaterial extends Material {
            constructor(parameters?: SpriteMaterialParameters);
            /**
                * @default 'SpriteMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default 0
                */
            rotation: number;
            /**
                * @default true
                */
            sizeAttenuation: boolean;
            /**
                * @default true
                */
            transparent: boolean;
            readonly isSpriteMaterial: true;
            /**
                * @internal
                */
            setValues(parameters: SpriteMaterialParameters): void;
            /**
                * @internal
                */
            copy(source: SpriteMaterial): this;
    }
}

declare module 'three/src/materials/RawShaderMaterial' {
    import { ShaderMaterialParameters, ShaderMaterial } from 'three/src/materials/ShaderMaterial';
    export class RawShaderMaterial extends ShaderMaterial {
        constructor(parameters?: ShaderMaterialParameters);
    }
}

declare module 'three/src/materials/ShaderMaterial' {
    import { IUniform } from 'three/src/renderers/shaders/UniformsLib';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { GLSLVersion } from 'three/src/constants';
    export interface ShaderMaterialParameters extends MaterialParameters {
            uniforms?: {
                    [uniform: string]: IUniform;
            } | undefined;
            vertexShader?: string | undefined;
            fragmentShader?: string | undefined;
            linewidth?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            lights?: boolean | undefined;
            clipping?: boolean | undefined;
            extensions?: {
                    derivatives?: boolean | undefined;
                    fragDepth?: boolean | undefined;
                    drawBuffers?: boolean | undefined;
                    shaderTextureLOD?: boolean | undefined;
            } | undefined;
            glslVersion?: GLSLVersion | undefined;
    }
    export class ShaderMaterial extends Material {
            constructor(parameters?: ShaderMaterialParameters);
            /**
                * @default 'ShaderMaterial'
                * @internal
                */
            type: string;
            /**
                * @default {}
                */
            defines: {
                    [key: string]: any;
            };
            /**
                * @default {}
                */
            uniforms: {
                    [uniform: string]: IUniform;
            };
            vertexShader: string;
            fragmentShader: string;
            /**
                * @default 1
                */
            linewidth: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default false
                */
            fog: boolean;
            /**
                * @default false
                */
            lights: boolean;
            /**
                * @default false
                */
            clipping: boolean;
            /**
                * @deprecated Use .derivatives extensions.derivatives instead.
                */
            derivatives: any;
            /**
                * @default { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }
                */
            extensions: {
                    derivatives: boolean;
                    fragDepth: boolean;
                    drawBuffers: boolean;
                    shaderTextureLOD: boolean;
            };
            /**
                * @default { 'color': [ 1, 1, 1 ], 'uv': [ 0, 0 ], 'uv2': [ 0, 0 ] }
                */
            defaultAttributeValues: any;
            /**
                * @default undefined
                */
            index0AttributeName: string | undefined;
            /**
                * @default false
                */
            uniformsNeedUpdate: boolean;
            /**
                * @default null
                */
            glslVersion: GLSLVersion | null;
            isShaderMaterial: boolean;
            /**
                * @internal
                */
            setValues(parameters: ShaderMaterialParameters): void;
            /**
                * @internal
                */
            toJSON(meta: any): any;
    }
}

declare module 'three/src/materials/PointsMaterial' {
    import { Material, MaterialParameters } from 'three/src/materials/Material';
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { ColorRepresentation } from 'three/src/utils';
    export interface PointsMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            map?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            size?: number | undefined;
            sizeAttenuation?: boolean | undefined;
    }
    export class PointsMaterial extends Material {
            constructor(parameters?: PointsMaterialParameters);
            /**
                * @default 'PointsMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default 1
                */
            size: number;
            /**
                * @default true
                */
            sizeAttenuation: boolean;
            /**
                * @internal
                */
            setValues(parameters: PointsMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshPhysicalMaterial' {
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { MeshStandardMaterialParameters, MeshStandardMaterial } from 'three/src/materials/MeshStandardMaterial';
    import { Color } from 'three/src/math/Color';
    export interface MeshPhysicalMaterialParameters extends MeshStandardMaterialParameters {
            clearcoat?: number | undefined;
            clearcoatMap?: Texture | null | undefined;
            clearcoatRoughness?: number | undefined;
            clearcoatRoughnessMap?: Texture | null | undefined;
            clearcoatNormalScale?: Vector2 | undefined;
            clearcoatNormalMap?: Texture | null | undefined;
            reflectivity?: number | undefined;
            ior?: number | undefined;
            sheen?: number | undefined;
            sheenColor?: Color | undefined;
            sheenRoughness?: number | undefined;
            transmission?: number | undefined;
            transmissionMap?: Texture | null | undefined;
            attenuationDistance?: number | undefined;
            attenuationColor?: Color | undefined;
            specularIntensity?: number | undefined;
            specularColor?: Color | undefined;
            specularIntensityMap?: Texture | null | undefined;
            specularColorMap?: Texture | null | undefined;
    }
    export class MeshPhysicalMaterial extends MeshStandardMaterial {
            constructor(parameters?: MeshPhysicalMaterialParameters);
            /**
                * @default 'MeshPhysicalMaterial'
                * @internal
                */
            type: string;
            /**
                * @default { 'STANDARD': '', 'PHYSICAL': '' }
                */
            defines: {
                    [key: string]: any;
            };
            /**
                * @default 0
                */
            clearcoat: number;
            /**
                * @default null
                */
            clearcoatMap: Texture | null;
            /**
                * @default 0
                */
            clearcoatRoughness: number;
            /**
                * @default null
                */
            clearcoatRoughnessMap: Texture | null;
            /**
                * @default new THREE.Vector2( 1, 1 )
                */
            clearcoatNormalScale: Vector2;
            /**
                * @default null
                */
            clearcoatNormalMap: Texture | null;
            /**
                * @default 0.5
                */
            reflectivity: number;
            /**
                * @default 1.5
                */
            ior: number;
            /**
                * @default 0.0
                */
            sheen: number;
            /**
                * @default Color( 0x000000 )
                */
            sheenColor: Color;
            /**
                * @default null
                */
            sheenColorMap: Texture | null;
            /**
                * @default 1.0
                */
            sheenRoughness: number;
            /**
                * @default null
                */
            sheenRoughnessMap: Texture | null;
            /**
                * @default 0
                */
            transmission: number;
            /**
                * @default null
                */
            transmissionMap: Texture | null;
            /**
                * @default 0.01
                * @internal
                */
            thickness: number;
            /**
                * @default null
                * @internal
                */
            thicknessMap: Texture | null;
            /**
                * @default 0.0
                * @internal
                */
            attenuationDistance: number;
            /**
                * @default Color( 1, 1, 1 )
                * @internal
                */
            attenuationColor: Color;
            /**
                * @default 1.0
                */
            specularIntensity: number;
            /**
                * @default Color(1, 1, 1)
                */
            specularColor: Color;
            /**
                * @default null
                */
            specularIntensityMap: Texture | null;
            /**
                * @default null
                */
            specularColorMap: Texture | null;
    }
}

declare module 'three/src/materials/MeshStandardMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { NormalMapTypes } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshStandardMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            roughness?: number | undefined;
            metalness?: number | undefined;
            map?: Texture | null | undefined;
            lightMap?: Texture | null | undefined;
            lightMapIntensity?: number | undefined;
            aoMap?: Texture | null | undefined;
            aoMapIntensity?: number | undefined;
            emissive?: ColorRepresentation | undefined;
            emissiveIntensity?: number | undefined;
            emissiveMap?: Texture | null | undefined;
            bumpMap?: Texture | null | undefined;
            bumpScale?: number | undefined;
            normalMap?: Texture | null | undefined;
            normalMapType?: NormalMapTypes | undefined;
            normalScale?: Vector2 | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            roughnessMap?: Texture | null | undefined;
            metalnessMap?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            envMap?: Texture | null | undefined;
            envMapIntensity?: number | undefined;
            refractionRatio?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            flatShading?: boolean | undefined;
    }
    export class MeshStandardMaterial extends Material {
            constructor(parameters?: MeshStandardMaterialParameters);
            /**
                * @default 'MeshStandardMaterial'
                * @internal
                */
            type: string;
            /**
                * @default { 'STANDARD': '' }
                */
            defines: {
                    [key: string]: any;
            };
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default 1
                */
            roughness: number;
            /**
                * @default 0
                */
            metalness: number;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            lightMap: Texture | null;
            /**
                * @default 1
                */
            lightMapIntensity: number;
            /**
                * @default null
                */
            aoMap: Texture | null;
            /**
                * @default 1
                */
            aoMapIntensity: number;
            /**
                * @default new THREE.Color( 0x000000 )
                */
            emissive: Color;
            /**
                * @default 1
                */
            emissiveIntensity: number;
            /**
                * @default null
                */
            emissiveMap: Texture | null;
            /**
                * @default null
                */
            bumpMap: Texture | null;
            /**
                * @default 1
                */
            bumpScale: number;
            /**
                * @default null
                */
            normalMap: Texture | null;
            /**
                * @default THREE.TangentSpaceNormalMap
                */
            normalMapType: NormalMapTypes;
            /**
                * @default new THREE.Vector2( 1, 1 )
                */
            normalScale: Vector2;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default null
                */
            roughnessMap: Texture | null;
            /**
                * @default null
                */
            metalnessMap: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default null
                */
            envMap: Texture | null;
            /**
                * @default 1
                */
            envMapIntensity: number;
            /**
                * @default 0.98
                * @internal
                */
            refractionRatio: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default 'round'
                */
            wireframeLinecap: string;
            /**
                * @default 'round'
                */
            wireframeLinejoin: string;
            /**
                * @default false
                */
            flatShading: boolean;
            isMeshStandardMaterial: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshStandardMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshPhongMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Combine, NormalMapTypes } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshPhongMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            specular?: ColorRepresentation | undefined;
            shininess?: number | undefined;
            opacity?: number | undefined;
            map?: Texture | null | undefined;
            lightMap?: Texture | null | undefined;
            lightMapIntensity?: number | undefined;
            aoMap?: Texture | null | undefined;
            aoMapIntensity?: number | undefined;
            emissive?: ColorRepresentation | undefined;
            emissiveIntensity?: number | undefined;
            emissiveMap?: Texture | null | undefined;
            bumpMap?: Texture | null | undefined;
            bumpScale?: number | undefined;
            normalMap?: Texture | null | undefined;
            normalMapType?: NormalMapTypes | undefined;
            normalScale?: Vector2 | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            specularMap?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            envMap?: Texture | null | undefined;
            combine?: Combine | undefined;
            reflectivity?: number | undefined;
            refractionRatio?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            wireframeLinecap?: string | undefined;
            wireframeLinejoin?: string | undefined;
            flatShading?: boolean | undefined;
    }
    export class MeshPhongMaterial extends Material {
            constructor(parameters?: MeshPhongMaterialParameters);
            /**
                * @default 'MeshNormalMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default new THREE.Color( 0x111111 )
                */
            specular: Color;
            /**
                * @default 30
                */
            shininess: number;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            lightMap: Texture | null;
            /**
                * @default null
                */
            lightMapIntensity: number;
            /**
                * @default null
                */
            aoMap: Texture | null;
            /**
                * @default null
                */
            aoMapIntensity: number;
            /**
                * @default new THREE.Color( 0x000000 )
                */
            emissive: Color;
            /**
                * @default 1
                */
            emissiveIntensity: number;
            /**
                * @default null
                */
            emissiveMap: Texture | null;
            /**
                * @default null
                */
            bumpMap: Texture | null;
            /**
                * @default 1
                */
            bumpScale: number;
            /**
                * @default null
                */
            normalMap: Texture | null;
            /**
                * @default THREE.TangentSpaceNormalMap
                */
            normalMapType: NormalMapTypes;
            /**
                * @default new Vector2( 1, 1 )
                */
            normalScale: Vector2;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default null
                */
            specularMap: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default null
                */
            envMap: Texture | null;
            /**
                * @default THREE.MultiplyOperation
                */
            combine: Combine;
            /**
                * @default 1
                */
            reflectivity: number;
            /**
                * @default 0.98
                */
            refractionRatio: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default 'round'
                */
            wireframeLinecap: string;
            /**
                * @default 'round'
                */
            wireframeLinejoin: string;
            /**
                * @default false
                */
            flatShading: boolean;
            /**
                * @deprecated Use THREE.MeshStandardMaterial instead.
                */
            metal: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshPhongMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshToonMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { NormalMapTypes } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshToonMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            opacity?: number | undefined;
            gradientMap?: Texture | null | undefined;
            map?: Texture | null | undefined;
            lightMap?: Texture | null | undefined;
            lightMapIntensity?: number | undefined;
            aoMap?: Texture | null | undefined;
            aoMapIntensity?: number | undefined;
            emissive?: ColorRepresentation | undefined;
            emissiveIntensity?: number | undefined;
            emissiveMap?: Texture | null | undefined;
            bumpMap?: Texture | null | undefined;
            bumpScale?: number | undefined;
            normalMap?: Texture | null | undefined;
            normalMapType?: NormalMapTypes | undefined;
            normalScale?: Vector2 | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            alphaMap?: Texture | null | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            wireframeLinecap?: string | undefined;
            wireframeLinejoin?: string | undefined;
    }
    export class MeshToonMaterial extends Material {
            constructor(parameters?: MeshToonMaterialParameters);
            /**
                * @default 'MeshToonMaterial'
                * @internal
                */
            type: string;
            /**
                * @default { 'TOON': '' }
                * @internal
                */
            defines: {
                    [key: string]: any;
            };
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default null
                */
            gradientMap: Texture | null;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            lightMap: Texture | null;
            /**
                * @default 1
                */
            lightMapIntensity: number;
            /**
                * @default null
                */
            aoMap: Texture | null;
            /**
                * @default 1
                */
            aoMapIntensity: number;
            /**
                * @default new THREE.Color( 0x000000 )
                */
            emissive: Color;
            /**
                * @default 1
                */
            emissiveIntensity: number;
            /**
                * @default null
                */
            emissiveMap: Texture | null;
            /**
                * @default null
                */
            bumpMap: Texture | null;
            /**
                * @default 1
                */
            bumpScale: number;
            /**
                * @default null
                */
            normalMap: Texture | null;
            /**
                * @default THREE.TangentSpaceNormalMap
                */
            normalMapType: NormalMapTypes;
            /**
                * @default new THREE.Vector2( 1, 1 )
                */
            normalScale: Vector2;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default 'round'
                */
            wireframeLinecap: string;
            /**
                * @default 'round'
                */
            wireframeLinejoin: string;
            /**
                * @internal
                */
            setValues(parameters: MeshToonMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshNormalMaterial' {
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { NormalMapTypes } from 'three/src/constants';
    export interface MeshNormalMaterialParameters extends MaterialParameters {
            bumpMap?: Texture | null | undefined;
            bumpScale?: number | undefined;
            normalMap?: Texture | null | undefined;
            normalMapType?: NormalMapTypes | undefined;
            normalScale?: Vector2 | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            flatShading?: boolean | undefined;
    }
    export class MeshNormalMaterial extends Material {
            constructor(parameters?: MeshNormalMaterialParameters);
            /**
                * @default 'MeshNormalMaterial'
                * @internal
                */
            type: string;
            /**
                * @default null
                */
            bumpMap: Texture | null;
            /**
                * @default 1
                */
            bumpScale: number;
            /**
                * @default null
                */
            normalMap: Texture | null;
            /**
                * @default THREE.TangentSpaceNormalMap
                */
            normalMapType: NormalMapTypes;
            /**
                * @default new THREE.Vector2( 1, 1 )
                */
            normalScale: Vector2;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default false
                */
            flatShading: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshNormalMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshLambertMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Combine } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshLambertMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            emissive?: ColorRepresentation | undefined;
            emissiveIntensity?: number | undefined;
            emissiveMap?: Texture | null | undefined;
            map?: Texture | null | undefined;
            lightMap?: Texture | null | undefined;
            lightMapIntensity?: number | undefined;
            aoMap?: Texture | null | undefined;
            aoMapIntensity?: number | undefined;
            specularMap?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            envMap?: Texture | null | undefined;
            combine?: Combine | undefined;
            reflectivity?: number | undefined;
            refractionRatio?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
            wireframeLinecap?: string | undefined;
            wireframeLinejoin?: string | undefined;
    }
    export class MeshLambertMaterial extends Material {
            constructor(parameters?: MeshLambertMaterialParameters);
            /**
                * @default 'MeshLambertMaterial'
                * @internal
                */
            type: string;
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default new THREE.Color( 0x000000 )
                */
            emissive: Color;
            /**
                * @default 1
                */
            emissiveIntensity: number;
            /**
                * @default null
                */
            emissiveMap: Texture | null;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            lightMap: Texture | null;
            /**
                * @default 1
                */
            lightMapIntensity: number;
            /**
                * @default null
                */
            aoMap: Texture | null;
            /**
                * @default 1
                */
            aoMapIntensity: number;
            /**
                * @default null
                */
            specularMap: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default null
                */
            envMap: Texture | null;
            /**
                * @default THREE.MultiplyOperation
                */
            combine: Combine;
            /**
                * @default 1
                */
            reflectivity: number;
            /**
                * @default 0.98
                */
            refractionRatio: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default 'round'
                */
            wireframeLinecap: string;
            /**
                * @default 'round'
                */
            wireframeLinejoin: string;
            /**
                * @internal
                */
            setValues(parameters: MeshLambertMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshDepthMaterial' {
    import { DepthPackingStrategies } from 'three/src/constants';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Texture } from 'three/src/textures/Texture';
    export interface MeshDepthMaterialParameters extends MaterialParameters {
            map?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            depthPacking?: DepthPackingStrategies | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            wireframe?: boolean | undefined;
            wireframeLinewidth?: number | undefined;
    }
    export class MeshDepthMaterial extends Material {
            constructor(parameters?: MeshDepthMaterialParameters);
            /**
                * @default 'MeshDepthMaterial'
                * @internal
                */
            type: string;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default THREE.BasicDepthPacking
                */
            depthPacking: DepthPackingStrategies;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default false
                */
            wireframe: boolean;
            /**
                * @default 1
                */
            wireframeLinewidth: number;
            /**
                * @default false
                */
            fog: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshDepthMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshDistanceMaterial' {
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { Vector3 } from 'three/src/math/Vector3';
    import { Texture } from 'three/src/textures/Texture';
    export interface MeshDistanceMaterialParameters extends MaterialParameters {
            map?: Texture | null | undefined;
            alphaMap?: Texture | null | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            farDistance?: number | undefined;
            nearDistance?: number | undefined;
            referencePosition?: Vector3 | undefined;
    }
    export class MeshDistanceMaterial extends Material {
            constructor(parameters?: MeshDistanceMaterialParameters);
            /**
                * @default 'MeshDistanceMaterial'
                * @internal
                */
            type: string;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default 1000
                */
            farDistance: number;
            /**
                * @default 1
                */
            nearDistance: number;
            /**
                * @default new THREE.Vector3()
                */
            referencePosition: Vector3;
            /**
                * @default false
                */
            fog: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshDistanceMaterialParameters): void;
    }
}

declare module 'three/src/materials/MeshMatcapMaterial' {
    import { Color } from 'three/src/math/Color';
    import { Texture } from 'three/src/textures/Texture';
    import { Vector2 } from 'three/src/math/Vector2';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    import { NormalMapTypes } from 'three/src/constants';
    import { ColorRepresentation } from 'three/src/utils';
    export interface MeshMatcapMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            matcap?: Texture | null | undefined;
            map?: Texture | null | undefined;
            bumpMap?: Texture | null | undefined;
            bumpScale?: number | undefined;
            normalMap?: Texture | null | undefined;
            normalMapType?: NormalMapTypes | undefined;
            normalScale?: Vector2 | undefined;
            displacementMap?: Texture | null | undefined;
            displacementScale?: number | undefined;
            displacementBias?: number | undefined;
            alphaMap?: Texture | null | undefined;
            flatShading?: boolean | undefined;
    }
    export class MeshMatcapMaterial extends Material {
            constructor(parameters?: MeshMatcapMaterialParameters);
            /**
                * @default 'MeshMatcapMaterial'
                * @internal
                */
            type: string;
            /**
                * @default { 'MATCAP': '' }
                * @internal
                */
            defines: {
                    [key: string]: any;
            };
            /**
                * @default new THREE.Color( 0xffffff )
                */
            color: Color;
            /**
                * @default null
                */
            matcap: Texture | null;
            /**
                * @default null
                */
            map: Texture | null;
            /**
                * @default null
                */
            bumpMap: Texture | null;
            /**
                * @default 1
                */
            bumpScale: number;
            /**
                * @default null
                */
            normalMap: Texture | null;
            /**
                * @default THREE.TangentSpaceNormalMap
                */
            normalMapType: NormalMapTypes;
            /**
                * @default new Vector2( 1, 1 )
                */
            normalScale: Vector2;
            /**
                * @default null
                */
            displacementMap: Texture | null;
            /**
                * @default 1
                */
            displacementScale: number;
            /**
                * @default 0
                */
            displacementBias: number;
            /**
                * @default null
                */
            alphaMap: Texture | null;
            /**
                * @default false
                */
            flatShading: boolean;
            /**
                * @internal
                */
            setValues(parameters: MeshMatcapMaterialParameters): void;
    }
}

declare module 'three/src/materials/LineDashedMaterial' {
    import { LineBasicMaterial, LineBasicMaterialParameters } from 'three/src/materials/LineBasicMaterial';
    export interface LineDashedMaterialParameters extends LineBasicMaterialParameters {
            scale?: number | undefined;
            dashSize?: number | undefined;
            gapSize?: number | undefined;
    }
    export class LineDashedMaterial extends LineBasicMaterial {
            constructor(parameters?: LineDashedMaterialParameters);
            /**
                * @default 'LineDashedMaterial'
                * @internal
                */
            type: string;
            /**
                * @default 1
                */
            scale: number;
            /**
                * @default 1
                */
            dashSize: number;
            /**
                * @default 1
                */
            gapSize: number;
            readonly isLineDashedMaterial: true;
            /**
                * @internal
                */
            setValues(parameters: LineDashedMaterialParameters): void;
    }
}

declare module 'three/src/materials/LineBasicMaterial' {
    import { ColorRepresentation } from 'three/src/utils';
    import { Color } from 'three/src/math/Color';
    import { MaterialParameters, Material } from 'three/src/materials/Material';
    export interface LineBasicMaterialParameters extends MaterialParameters {
            color?: ColorRepresentation | undefined;
            linewidth?: number | undefined;
            linecap?: string | undefined;
            linejoin?: string | undefined;
    }
    export class LineBasicMaterial extends Material {
            constructor(parameters?: LineBasicMaterialParameters);
            /**
                * @default 'LineBasicMaterial'
                * @internal
                */
            type: string;
            /**
                * @default 0xffffff
                */
            color: Color;
            /**
                * @default 1
                */
            linewidth: number;
            /**
                * @default 'round'
                */
            linecap: string;
            /**
                * @default 'round'
                */
            linejoin: string;
            /**
                * @internal
                */
            setValues(parameters: LineBasicMaterialParameters): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLAttributes' {
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { InterleavedBufferAttribute } from 'three/src/core/InterleavedBufferAttribute';
    
    export class WebGLAttributes {
        constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, capabilities: WebGLCapabilities);
    
        get(attribute: BufferAttribute | InterleavedBufferAttribute): {
            buffer: WebGLBuffer;
            type: number;
            bytesPerElement: number;
            version: number;
        };
    
        remove(attribute: BufferAttribute | InterleavedBufferAttribute): void;
    
        update(attribute: BufferAttribute | InterleavedBufferAttribute, bufferType: number): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLCubeMaps' {
    import { WebGLRenderer } from 'three/src/renderers/WebGLRenderer';
    
    export class WebGLCubeMaps {
        constructor(renderer: WebGLRenderer);
    
        get(texture: any): any;
        dispose(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLBindingStates' {
    import { WebGLExtensions } from 'three/src/renderers/webgl/WebGLExtensions';
    import { WebGLAttributes } from 'three/src/renderers/webgl/WebGLAttributes';
    import { WebGLProgram } from 'three/src/renderers/webgl/WebGLProgram';
    import { WebGLCapabilities } from 'three/src/renderers/webgl/WebGLCapabilities';
    import { Object3D } from 'three/src/core/Object3D';
    import { BufferGeometry } from 'three/src/core/BufferGeometry';
    import { BufferAttribute } from 'three/src/core/BufferAttribute';
    import { Material } from 'three/src/materials/Material';
    
    export class WebGLBindingStates {
        constructor(
            gl: WebGLRenderingContext,
            extensions: WebGLExtensions,
            attributes: WebGLAttributes,
            capabilities: WebGLCapabilities,
        );
    
        setup(
            object: Object3D,
            material: Material,
            program: WebGLProgram,
            geometry: BufferGeometry,
            index: BufferAttribute,
        ): void;
        reset(): void;
        resetDefaultState(): void;
        dispose(): void;
        releaseStatesOfGeometry(): void;
        releaseStatesOfProgram(): void;
        initAttributes(): void;
        enableAttribute(attribute: number): void;
        disableUnusedAttributes(): void;
    }
}

declare module 'three/src/renderers/webgl/WebGLUtils' {
    import { CompressedPixelFormat, TextureEncoding } from 'three/src/constants';
    
    export class WebGLUtils {
        constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, extensions: any, capabilities: any);
    
        convert(p: CompressedPixelFormat, encoding?: TextureEncoding | null): void;
    }
}

